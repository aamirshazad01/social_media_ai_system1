{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/module.compiled.js","turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts","turbopack:///[project]/src/lib/supabase/index.ts/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/services/database/postService.ts","turbopack:///[project]/src/services/database/campaignService.ts","turbopack:///[project]/src/lib/encryption.ts","turbopack:///[project]/src/services/database/credentialService.ts","turbopack:///[project]/src/services/database/migrationService.ts"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const createBrowserClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call createBrowserClient() from the server but createBrowserClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts\",\n    \"createBrowserClient\",\n);\nexport const supabase = registerClientReference(\n    function() { throw new Error(\"Attempted to call supabase() from the server but supabase is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts\",\n    \"supabase\",\n);\n","/**\r\n * Post Service - Supabase Database Operations\r\n * Handles all CRUD operations for posts\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport { Post, PostStatus, Platform } from '@/types'\r\n\r\nexport class PostService {\r\n  /**\r\n   * Get all posts for the current user's workspace\r\n   */\r\n  static async getAllPosts(workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      // Transform database format to app format\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching posts:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a single post by ID\r\n   */\r\n  static async getPostById(postId: string, workspaceId: string): Promise<Post | null> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('id', postId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return data ? this.transformFromDB(data) : null\r\n    } catch (error) {\r\n      console.error('Error fetching post:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new post\r\n   */\r\n  static async createPost(post: Post, userId: string, workspaceId: string): Promise<Post> {\r\n    try {\r\n      const dbPost = this.transformToDB(post, userId, workspaceId)\r\n\r\n      const { data, error } = await supabase\n        .from('posts')\n        .insert(dbPost)\n        .select()\n        .maybeSingle<{ id: string }>()\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'create', 'post', data!.id)\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error creating post:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing post\r\n   */\r\n  static async updatePost(post: Post, userId: string, workspaceId: string): Promise<Post> {\r\n    try {\r\n      const dbPost = this.transformToDB(post, userId, workspaceId)\r\n\r\n      const { data, error } = await (supabase.from('posts') as any)\n        .update(dbPost)\n        .eq('id', post.id)\n        .eq('workspace_id', workspaceId)\n        .select()\n        .single()\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'update', 'post', (data as any).id)\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error updating post:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a post\r\n   */\r\n  static async deletePost(postId: string, userId: string, workspaceId: string): Promise<void> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('posts')\r\n        .delete()\r\n        .eq('id', postId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'delete', 'post', postId)\r\n    } catch (error) {\r\n      console.error('Error deleting post:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get posts by status\r\n   */\r\n  static async getPostsByStatus(status: PostStatus, workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('status', status)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching posts by status:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get posts by campaign\r\n   */\r\n  static async getPostsByCampaign(campaignId: string, workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('campaign_id', campaignId)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching posts by campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get scheduled posts (for publishing)\r\n   */\r\n  static async getScheduledPosts(workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const now = new Date().toISOString()\r\n\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('status', 'scheduled')\r\n        .lte('scheduled_at', now)\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching scheduled posts:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update post status\r\n   */\r\n  static async updatePostStatus(\r\n    postId: string,\r\n    status: PostStatus,\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      const updateData: any = { status }\r\n\r\n      // Add published_at timestamp when status is published\r\n      if (status === 'published') {\r\n        updateData.published_at = new Date().toISOString()\r\n      }\r\n\r\n      const { error } = await (supabase.from('posts') as any)\n        .update(updateData)\n        .eq('id', postId)\n        .eq('workspace_id', workspaceId)\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'update_status', 'post', postId, { status })\r\n    } catch (error) {\r\n      console.error('Error updating post status:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform database row to Post type\r\n   */\r\n  private static transformFromDB(dbPost: any): Post {\r\n    return {\r\n      id: dbPost.id,\r\n      topic: dbPost.topic,\r\n      platforms: dbPost.platforms as Platform[],\r\n      content: dbPost.content,\r\n      status: dbPost.status as PostStatus,\r\n      createdAt: dbPost.created_at,\r\n      scheduledAt: dbPost.scheduled_at,\r\n      publishedAt: dbPost.published_at,\r\n      campaignId: dbPost.campaign_id,\r\n      engagementScore: dbPost.engagement_score,\r\n      engagementSuggestions: dbPost.engagement_suggestions,\r\n      // These fields are stored in content JSONB\r\n      generatedImage: dbPost.content?.generatedImage,\r\n      generatedVideoUrl: dbPost.content?.generatedVideoUrl,\r\n      isGeneratingImage: dbPost.content?.isGeneratingImage || false,\r\n      isGeneratingVideo: dbPost.content?.isGeneratingVideo || false,\r\n      videoGenerationStatus: dbPost.content?.videoGenerationStatus,\r\n      videoOperation: dbPost.content?.videoOperation,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform Post type to database format\r\n   */\r\n  private static transformToDB(post: Post, userId: string, workspaceId: string): any {\r\n    // Extract fields that go into content JSONB\r\n    const { generatedImage, generatedVideoUrl, isGeneratingImage, isGeneratingVideo, videoGenerationStatus, videoOperation, content, ...rest } = post\r\n\r\n    return {\r\n      id: post.id,\r\n      workspace_id: workspaceId,\r\n      created_by: userId,\r\n      topic: post.topic,\r\n      platforms: post.platforms,\r\n      content: {\r\n        ...content,\r\n        generatedImage,\r\n        generatedVideoUrl,\r\n        isGeneratingImage,\r\n        isGeneratingVideo,\r\n        videoGenerationStatus,\r\n        videoOperation,\r\n      },\r\n      status: post.status,\r\n      scheduled_at: post.scheduledAt,\r\n      published_at: post.publishedAt,\r\n      campaign_id: post.campaignId,\r\n      engagement_score: post.engagementScore,\r\n      engagement_suggestions: post.engagementSuggestions,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log activity to activity_logs table\r\n   */\r\n  private static async logActivity(\r\n    workspaceId: string,\r\n    userId: string,\r\n    action: string,\r\n    resourceType: string,\r\n    resourceId: string,\r\n    details: any = {}\r\n  ): Promise<void> {\r\n    try {\r\n      await (supabase.from('activity_logs') as any).insert({\n        workspace_id: workspaceId,\n        user_id: userId,\n        action,\n        resource_type: resourceType,\n        resource_id: resourceId,\n        details: details || null,\n      })\n    } catch (error) {\r\n      console.error('Error logging activity:', error)\r\n      // Don't throw - activity logging shouldn't break the main operation\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Campaign Service - Supabase Database Operations\r\n * Handles all CRUD operations for campaigns\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport { Campaign } from '@/types'\nimport type { Database } from '@/lib/supabase/types'\n\r\nexport class CampaignService {\r\n  /**\r\n   * Get all campaigns for workspace\r\n   */\r\n  static async getAllCampaigns(workspaceId: string): Promise<Campaign[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('campaigns')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching campaigns:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get campaign by ID\r\n   */\r\n  static async getCampaignById(campaignId: string, workspaceId: string): Promise<Campaign | null> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('campaigns')\r\n        .select('*')\r\n        .eq('id', campaignId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return data ? this.transformFromDB(data) : null\r\n    } catch (error) {\r\n      console.error('Error fetching campaign:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new campaign\r\n   */\r\n  static async createCampaign(\r\n    workspaceId: string,\r\n    name: string,\r\n    description?: string,\r\n    startDate?: string,\r\n    endDate?: string,\r\n    goals?: string[]\r\n  ): Promise<Campaign> {\r\n    try {\r\n      const campaign: Database['public']['Tables']['campaigns']['Insert'] = {\n        workspace_id: workspaceId,\n        name,\n        goal: description || null,\n        color: this.getRandomCampaignColor(),\n        start_date: startDate || new Date().toISOString(),\n        end_date: endDate || null,\n      }\n\r\n      const { data, error } = await (supabase\n        .from('campaigns') as any)\n        .insert(campaign)\n        .select()\n        .single()\n\r\n      if (error) throw error\r\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error creating campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a campaign\r\n   */\r\n  static async updateCampaign(campaign: Campaign, workspaceId: string): Promise<Campaign> {\r\n    try {\r\n      const dbCampaign = {\n        name: campaign.name,\n        goal: campaign.description || null,\n        color: campaign.color,\n        start_date: campaign.startDate,\n        end_date: campaign.endDate ?? null,\n      }\n\r\n      const { data, error } = await (supabase\n        .from('campaigns') as any)\n        .update(dbCampaign)\n        .eq('id', campaign.id)\n        .eq('workspace_id', workspaceId)\n        .select()\n        .single()\n\r\n      if (error) throw error\r\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error updating campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a campaign\r\n   */\r\n  static async deleteCampaign(campaignId: string, workspaceId: string): Promise<void> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('campaigns')\r\n        .delete()\r\n        .eq('id', campaignId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n    } catch (error) {\r\n      console.error('Error deleting campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get posts count for a campaign\r\n   */\r\n  static async getCampaignPostsCount(campaignId: string, workspaceId: string): Promise<number> {\r\n    try {\r\n      const { count, error } = await supabase\r\n        .from('posts')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('campaign_id', campaignId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n\r\n      return count || 0\r\n    } catch (error) {\r\n      console.error('Error getting campaign posts count:', error)\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform database row to Campaign type\r\n   */\r\n  private static transformFromDB(dbCampaign: any): Campaign {\n    return {\n      id: dbCampaign.id,\n      name: dbCampaign.name,\n      description: dbCampaign.goal,\n      color: dbCampaign.color,\n      startDate: dbCampaign.start_date,\n      endDate: dbCampaign.end_date,\n      createdAt: dbCampaign.created_at,\n    }\n  }\n\r\n  /**\r\n   * Generate random campaign color\r\n   */\r\n  private static getRandomCampaignColor(): string {\r\n    const colors = [\r\n      '#8B5CF6', // Purple\r\n      '#EC4899', // Pink\r\n      '#F59E0B', // Amber\r\n      '#10B981', // Green\r\n      '#3B82F6', // Blue\r\n      '#EF4444', // Red\r\n      '#14B8A6', // Teal\r\n      '#F97316', // Orange\r\n    ]\r\n    return colors[Math.floor(Math.random() * colors.length)]\r\n  }\r\n}\r\n","/**\r\n * Simple Encryption Utility\r\n *\r\n * Note: This uses browser's SubtleCrypto API for encryption.\r\n * For production, consider using a backend service with server-side encryption.\r\n */\r\n\r\n// Generate a key from a passphrase\r\nasync function deriveKey(password: string, salt: Uint8Array): Promise<CryptoKey> {\r\n  const enc = new TextEncoder()\r\n  const keyMaterial = await window.crypto.subtle.importKey(\r\n    'raw',\r\n    enc.encode(password),\r\n    'PBKDF2',\r\n    false,\r\n    ['deriveBits', 'deriveKey']\r\n  )\r\n\r\n  return window.crypto.subtle.deriveKey(\r\n    {\r\n      name: 'PBKDF2',\r\n      salt: salt,\r\n      iterations: 100000,\r\n      hash: 'SHA-256',\r\n    },\r\n    keyMaterial,\r\n    { name: 'AES-GCM', length: 256 },\r\n    true,\r\n    ['encrypt', 'decrypt']\r\n  )\r\n}\r\n\r\n/**\r\n * Encrypt data using AES-GCM\r\n */\r\nexport async function encrypt(data: string, userSecret: string): Promise<string> {\r\n  try {\r\n    const enc = new TextEncoder()\r\n    const salt = window.crypto.getRandomValues(new Uint8Array(16))\r\n    const iv = window.crypto.getRandomValues(new Uint8Array(12))\r\n    const key = await deriveKey(userSecret, salt)\r\n\r\n    const encrypted = await window.crypto.subtle.encrypt(\r\n      {\r\n        name: 'AES-GCM',\r\n        iv: iv,\r\n      },\r\n      key,\r\n      enc.encode(data)\r\n    )\r\n\r\n    // Combine salt + iv + encrypted data\r\n    const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength)\r\n    combined.set(salt, 0)\r\n    combined.set(iv, salt.length)\r\n    combined.set(new Uint8Array(encrypted), salt.length + iv.length)\r\n\r\n    // Convert to base64\r\n    return btoa(String.fromCharCode(...combined))\r\n  } catch (error) {\r\n    console.error('Encryption error:', error)\r\n    throw new Error('Failed to encrypt data')\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt data using AES-GCM\r\n */\r\nexport async function decrypt(encryptedData: string, userSecret: string): Promise<string> {\r\n  try {\r\n    // Decode from base64\r\n    const combined = Uint8Array.from(atob(encryptedData), (c) => c.charCodeAt(0))\r\n\r\n    // Extract salt, iv, and encrypted data\r\n    const salt = combined.slice(0, 16)\r\n    const iv = combined.slice(16, 28)\r\n    const encrypted = combined.slice(28)\r\n\r\n    const key = await deriveKey(userSecret, salt)\r\n\r\n    const decrypted = await window.crypto.subtle.decrypt(\r\n      {\r\n        name: 'AES-GCM',\r\n        iv: iv,\r\n      },\r\n      key,\r\n      encrypted\r\n    )\r\n\r\n    const dec = new TextDecoder()\r\n    return dec.decode(decrypted)\r\n  } catch (error) {\r\n    console.error('Decryption error:', error)\r\n    throw new Error('Failed to decrypt data')\r\n  }\r\n}\r\n\r\n/**\r\n * Generate encryption key from user ID\r\n * In production, use a more secure key management system\r\n */\r\nexport function getUserEncryptionKey(userId: string): string {\r\n  // In production, this should be derived from a secure backend\r\n  // For now, we use a combination of user ID and a static salt\r\n  return `${userId}_encryption_key_v1`\r\n}\r\n","/**\r\n * Credential Service - Supabase Database Operations\r\n * Handles encrypted storage of social media credentials\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport { encrypt, decrypt, getUserEncryptionKey } from '@/lib/encryption'\r\nimport {\r\n  Platform,\r\n  TwitterCredentials,\r\n  LinkedInCredentials,\r\n  FacebookCredentials,\r\n  InstagramCredentials,\r\n  PlatformCredentials,\r\n} from '@/types'\r\n\r\ntype AnyCredentials = TwitterCredentials | LinkedInCredentials | FacebookCredentials | InstagramCredentials\r\n\r\nexport class CredentialService {\n  /**\r\n   * Save credentials for a platform\r\n   */\r\n  static async savePlatformCredentials(\r\n    platform: Platform,\r\n    credentials: AnyCredentials,\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      // Encrypt credentials\r\n      const encryptionKey = getUserEncryptionKey(userId)\r\n      const credentialsJson = JSON.stringify(credentials)\r\n      const encrypted = await encrypt(credentialsJson, encryptionKey)\r\n\r\n      // Check if credentials already exist\r\n      const { data: existing } = await supabase\n        .from('social_accounts')\n        .select('id')\n        .eq('workspace_id', workspaceId)\n        .eq('platform', platform)\n        .maybeSingle<{ id: string }>()\n\r\n      if (existing) {\r\n        // Update existing\r\n        const usernameVal = 'username' in credentials ? (credentials as any).username ?? null : null\n        const { error } = await (supabase\n          .from('social_accounts') as any)\n          .update({\n            credentials_encrypted: encrypted,\n            is_connected: credentials.isConnected,\n            username: usernameVal,\n            connected_at: credentials.isConnected ? new Date().toISOString() : null,\n            last_verified_at: new Date().toISOString(),\n          })\n          .eq('id', existing.id)\n\r\n        if (error) throw error\r\n      } else {\r\n        // Insert new\r\n        const usernameInsert = 'username' in credentials ? (credentials as any).username ?? null : null\n        const { error } = await (supabase.from('social_accounts') as any).insert({\n          workspace_id: workspaceId,\n          platform,\n          credentials_encrypted: encrypted,\n          is_connected: credentials.isConnected,\n          username: usernameInsert,\n          connected_at: credentials.isConnected ? new Date().toISOString() : null,\n          last_verified_at: new Date().toISOString(),\n        })\n\r\n        if (error) throw error\r\n      }\r\n    } catch (error) {\r\n      console.error('Error saving credentials:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get credentials for a specific platform\r\n   */\r\n  static async getPlatformCredentials(\n    platform: Platform,\n    userId: string,\n    workspaceId: string\n  ): Promise<AnyCredentials | null> {\n    try {\r\n      const { data, error } = await supabase\n        .from('social_accounts')\n        .select('credentials_encrypted')\n        .eq('workspace_id', workspaceId)\n        .eq('platform', platform)\n        .maybeSingle<{ credentials_encrypted: string }>()\n\r\n      if (error || !data) return null\r\n\r\n      // Decrypt credentials\r\n      const encryptionKey = getUserEncryptionKey(userId)\r\n      const decrypted = await decrypt(data.credentials_encrypted, encryptionKey)\r\n      const credentials = JSON.parse(decrypted)\r\n\r\n      return credentials\r\n    } catch (error) {\r\n      console.error('Error getting credentials:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all platform credentials\r\n   */\r\n  static async getAllCredentials(\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<PlatformCredentials> {\r\n    try {\r\n      const { data, error } = await supabase\n        .from('social_accounts')\n        .select('platform, credentials_encrypted')\n        .eq('workspace_id', workspaceId)\n\r\n      if (error) throw error\r\n\r\n      const credentials: PlatformCredentials = {}\r\n      const encryptionKey = getUserEncryptionKey(userId)\r\n\r\n      for (const account of (data || []) as Array<{ platform: string; credentials_encrypted: string }>) {\n        try {\r\n          const decrypted = await decrypt(account.credentials_encrypted, encryptionKey)\r\n          credentials[account.platform as Platform] = JSON.parse(decrypted)\r\n        } catch (error) {\r\n          console.error(`Error decrypting ${account.platform} credentials:`, error)\r\n        }\r\n      }\r\n\r\n      return credentials\r\n    } catch (error) {\r\n      console.error('Error getting all credentials:', error)\r\n      return {}\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a platform is connected\r\n   */\r\n  static async isPlatformConnected(platform: Platform, workspaceId: string): Promise<boolean> {\r\n    try {\r\n      const { data, error } = await supabase\n        .from('social_accounts')\n        .select('is_connected')\n        .eq('workspace_id', workspaceId)\n        .eq('platform', platform)\n        .maybeSingle<{ is_connected: boolean }>()\n\r\n      if (error || !data) return false\r\n\r\n      return data.is_connected\r\n    } catch (error) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get connection summary for all platforms\r\n   */\r\n  static async getConnectionSummary(workspaceId: string): Promise<Record<Platform, boolean>> {\r\n    try {\r\n      const { data, error } = await supabase\n        .from('social_accounts')\n        .select('platform, is_connected')\n        .eq('workspace_id', workspaceId)\n\r\n      if (error) throw error\r\n\r\n      const summary: Record<Platform, boolean> = {\r\n        twitter: false,\r\n        linkedin: false,\r\n        facebook: false,\r\n        instagram: false,\r\n      }\r\n\r\n      for (const account of (data || []) as Array<{ platform: Platform; is_connected: boolean }>) {\n        summary[account.platform] = account.is_connected\n      }\n\r\n      return summary\r\n    } catch (error) {\r\n      console.error('Error getting connection summary:', error)\r\n      return {\r\n        twitter: false,\r\n        linkedin: false,\r\n        facebook: false,\r\n        instagram: false,\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect a platform\r\n   */\r\n  static async disconnectPlatform(\r\n    platform: Platform,\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      // Get existing credentials\r\n      const credentials = await this.getPlatformCredentials(platform, userId, workspaceId)\r\n      if (!credentials) return\r\n\r\n      // Update to disconnected\r\n      credentials.isConnected = false\r\n      await this.savePlatformCredentials(platform, credentials, userId, workspaceId)\r\n    } catch (error) {\r\n      console.error('Error disconnecting platform:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete platform credentials completely\r\n   */\r\n  static async deletePlatformCredentials(\r\n    platform: Platform,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('social_accounts')\r\n        .delete()\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('platform', platform)\r\n\r\n      if (error) throw error\r\n    } catch (error) {\r\n      console.error('Error deleting credentials:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all credentials for workspace\r\n   */\r\n  static async clearAllCredentials(workspaceId: string): Promise<void> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('social_accounts')\r\n        .delete()\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n    } catch (error) {\r\n      console.error('Error clearing all credentials:', error)\r\n      throw error\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Migration Service\r\n * Handles one-time migration of data from localStorage to Supabase\r\n */\r\n\r\nimport { PostService } from './postService'\r\nimport { CampaignService } from './campaignService'\r\nimport { CredentialService } from './credentialService'\r\nimport { Post, Campaign, PlatformCredentials } from '@/types'\r\n\r\nexport class MigrationService {\r\n  /**\r\n   * Check if migration is needed\r\n   */\r\n  static needsMigration(): boolean {\r\n    // Check if there's data in localStorage\r\n    const hasPosts = localStorage.getItem('socialMediaPosts') !== null\r\n    const hasCampaigns = localStorage.getItem('campaigns') !== null\r\n    const hasCredentials = localStorage.getItem('social_media_credentials') !== null\r\n\r\n    // Check if migration has been completed before\r\n    const migrationCompleted = localStorage.getItem('migration_completed') === 'true'\r\n\r\n    return (hasPosts || hasCampaigns || hasCredentials) && !migrationCompleted\r\n  }\r\n\r\n  /**\r\n   * Migrate all data from localStorage to Supabase\r\n   */\r\n  static async migrateAllData(userId: string, workspaceId: string): Promise<{\r\n    success: boolean\r\n    postsCount: number\r\n    campaignsCount: number\r\n    credentialsCount: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let postsCount = 0\r\n    let campaignsCount = 0\r\n    let credentialsCount = 0\r\n\r\n    try {\r\n      // Migrate posts\r\n      const postsMigrationResult = await this.migratePosts(userId, workspaceId)\r\n      postsCount = postsMigrationResult.count\r\n      if (postsMigrationResult.errors.length > 0) {\r\n        errors.push(...postsMigrationResult.errors)\r\n      }\r\n\r\n      // Migrate campaigns\r\n      const campaignsMigrationResult = await this.migrateCampaigns(workspaceId)\r\n      campaignsCount = campaignsMigrationResult.count\r\n      if (campaignsMigrationResult.errors.length > 0) {\r\n        errors.push(...campaignsMigrationResult.errors)\r\n      }\r\n\r\n      // Migrate credentials\r\n      const credentialsMigrationResult = await this.migrateCredentials(userId, workspaceId)\r\n      credentialsCount = credentialsMigrationResult.count\r\n      if (credentialsMigrationResult.errors.length > 0) {\r\n        errors.push(...credentialsMigrationResult.errors)\r\n      }\r\n\r\n      // Mark migration as completed\r\n      localStorage.setItem('migration_completed', 'true')\r\n\r\n      return {\r\n        success: errors.length === 0,\r\n        postsCount,\r\n        campaignsCount,\r\n        credentialsCount,\r\n        errors,\r\n      }\r\n    } catch (error) {\r\n      console.error('Migration error:', error)\r\n      errors.push('Failed to complete migration: ' + (error as Error).message)\r\n      return {\r\n        success: false,\r\n        postsCount,\r\n        campaignsCount,\r\n        credentialsCount,\r\n        errors,\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Migrate posts from localStorage\r\n   */\r\n  private static async migratePosts(userId: string, workspaceId: string): Promise<{\r\n    count: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let count = 0\r\n\r\n    try {\r\n      const postsJson = localStorage.getItem('socialMediaPosts')\r\n      if (!postsJson) return { count: 0, errors: [] }\r\n\r\n      const posts: Post[] = JSON.parse(postsJson)\r\n\r\n      for (const post of posts) {\r\n        try {\r\n          // Check if post already exists in database\r\n          const existing = await PostService.getPostById(post.id, workspaceId)\r\n          if (existing) {\r\n            console.log(`Post ${post.id} already exists, skipping`)\r\n            continue\r\n          }\r\n\r\n          await PostService.createPost(post, userId, workspaceId)\r\n          count++\r\n        } catch (error) {\r\n          console.error(`Error migrating post ${post.id}:`, error)\r\n          errors.push(`Failed to migrate post \"${post.topic}\": ${(error as Error).message}`)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing posts from localStorage:', error)\r\n      errors.push('Failed to parse posts from localStorage')\r\n    }\r\n\r\n    return { count, errors }\r\n  }\r\n\r\n  /**\r\n   * Migrate campaigns from localStorage\r\n   */\r\n  private static async migrateCampaigns(workspaceId: string): Promise<{\r\n    count: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let count = 0\r\n\r\n    try {\r\n      const campaignsJson = localStorage.getItem('campaigns')\r\n      if (!campaignsJson) return { count: 0, errors: [] }\r\n\r\n      const campaigns: Campaign[] = JSON.parse(campaignsJson)\r\n\r\n      for (const campaign of campaigns) {\r\n        try {\r\n          // Check if campaign already exists\r\n          const existing = await CampaignService.getCampaignById(campaign.id, workspaceId)\r\n          if (existing) {\r\n            console.log(`Campaign ${campaign.id} already exists, skipping`)\r\n            continue\r\n          }\r\n\r\n          // Create campaign directly with ID preservation\r\n          const { error } = await (await import('@/lib/supabase')).supabase\n            .from('campaigns' as any)\n            .insert({\n              id: campaign.id, // Preserve original ID\n              workspace_id: workspaceId,\n              name: campaign.name,\n              goal: campaign.description || null,\n              color: campaign.color,\n              start_date: campaign.startDate,\n              end_date: campaign.endDate ?? null,\n            } as any)\n\r\n          if (error) throw error\r\n\r\n          count++\r\n        } catch (error) {\r\n          console.error(`Error migrating campaign ${campaign.id}:`, error)\r\n          errors.push(`Failed to migrate campaign \"${campaign.name}\": ${(error as Error).message}`)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing campaigns from localStorage:', error)\r\n      errors.push('Failed to parse campaigns from localStorage')\r\n    }\r\n\r\n    return { count, errors }\r\n  }\r\n\r\n  /**\r\n   * Migrate credentials from localStorage\r\n   */\r\n  private static async migrateCredentials(userId: string, workspaceId: string): Promise<{\r\n    count: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let count = 0\r\n\r\n    try {\r\n      const credentialsObfuscated = localStorage.getItem('social_media_credentials')\r\n      if (!credentialsObfuscated) return { count: 0, errors: [] }\r\n\r\n      // Deobfuscate (reverse + base64 decode)\r\n      const reversed = credentialsObfuscated.split('').reverse().join('')\r\n      const credentialsJson = atob(reversed)\r\n      const credentials: PlatformCredentials = JSON.parse(credentialsJson)\r\n\r\n      for (const [platform, platformCredentials] of Object.entries(credentials)) {\r\n        try {\r\n          if (!platformCredentials) continue\r\n\r\n          // Check if credentials already exist\r\n          const existing = await CredentialService.isPlatformConnected(\r\n            platform as any,\r\n            workspaceId\r\n          )\r\n          if (existing) {\r\n            console.log(`Credentials for ${platform} already exist, skipping`)\r\n            continue\r\n          }\r\n\r\n          await CredentialService.savePlatformCredentials(\r\n            platform as any,\r\n            platformCredentials as any,\r\n            userId,\r\n            workspaceId\r\n          )\r\n          count++\r\n        } catch (error) {\r\n          console.error(`Error migrating credentials for ${platform}:`, error)\r\n          errors.push(`Failed to migrate ${platform} credentials: ${(error as Error).message}`)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing credentials from localStorage:', error)\r\n      errors.push('Failed to parse credentials from localStorage')\r\n    }\r\n\r\n    return { count, errors }\r\n  }\r\n\r\n  /**\r\n   * Clear localStorage data after successful migration\r\n   */\r\n  static clearLocalStorageData(): void {\r\n    try {\r\n      localStorage.removeItem('socialMediaPosts')\r\n      localStorage.removeItem('campaigns')\r\n      localStorage.removeItem('social_media_credentials')\r\n      console.log('LocalStorage data cleared after migration')\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset migration status (for testing)\r\n   */\r\n  static resetMigrationStatus(): void {\r\n    localStorage.removeItem('migration_completed')\r\n  }\r\n}\r\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactServerDOMTurbopackServer"],"mappings":"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","ignoreList":[0,1,2]}