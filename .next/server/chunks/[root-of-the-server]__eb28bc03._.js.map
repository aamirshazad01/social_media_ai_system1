{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/module.compiled.js","turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts","turbopack:///[project]/src/lib/supabase/index.ts/__nextjs-internal-proxy.mjs","turbopack:///[project]/src/services/database/auditLogService.ts","turbopack:///[project]/src/services/database/credentialService.ts","turbopack:///[project]/src/lib/auth/encryptionManager.ts","turbopack:///[project]/src/services/database/postService.ts","turbopack:///[project]/src/services/database/campaignService.ts","turbopack:///[project]/src/services/database/index.ts","turbopack:///[project]/src/services/database/migrationService.ts"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const createBrowserClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call createBrowserClient() from the server but createBrowserClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts\",\n    \"createBrowserClient\",\n);\nexport const supabase = registerClientReference(\n    function() { throw new Error(\"Attempted to call supabase() from the server but supabase is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts\",\n    \"supabase\",\n);\n","/**\r\n * Audit Log Service\r\n * Logs all credential-related events for compliance and debugging\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport type { Platform } from '@/types'\r\n\r\nexport interface AuditEventParams {\r\n  workspaceId: string\r\n  userId: string\r\n  platform: Platform\r\n  action: string\r\n  status: 'success' | 'failed' | 'partial'\r\n  errorMessage?: string\r\n  errorCode?: string\r\n  ipAddress?: string\r\n  userAgent?: string\r\n  requestPath?: string\r\n  metadata?: any\r\n}\r\n\r\n/**\r\n * Log an audit event\r\n */\r\nexport async function logAuditEvent({\r\n  workspaceId,\r\n  userId,\r\n  platform,\r\n  action,\r\n  status,\r\n  errorMessage,\r\n  errorCode,\r\n  ipAddress,\r\n  userAgent,\r\n  requestPath,\r\n  metadata,\r\n}: AuditEventParams): Promise<void> {\r\n  try {\r\n    const { error } = await supabase.from('credential_audit_log').insert({\r\n      workspace_id: workspaceId,\r\n      user_id: userId,\r\n      platform,\r\n      action,\r\n      status,\r\n      error_message: errorMessage || null,\r\n      error_code: errorCode || null,\r\n      ip_address: ipAddress || null,\r\n      user_agent: userAgent || null,\r\n      request_path: requestPath || null,\r\n      metadata: metadata || null,\r\n    } as any)\r\n\r\n    if (error) {\r\n      console.error('Failed to insert audit log:', error)\r\n    }\r\n  } catch (error) {\r\n    console.error('Audit logging error:', error)\r\n    // Don't throw - logging failures shouldn't break the app\r\n  }\r\n}\r\n\r\n/**\r\n * Get audit logs for a workspace\r\n */\r\nexport async function getAuditLogs(\r\n  workspaceId: string,\r\n  filters?: {\r\n    platform?: Platform\r\n    action?: string\r\n    status?: string\r\n    limit?: number\r\n    offset?: number\r\n    startDate?: Date\r\n    endDate?: Date\r\n  }\r\n): Promise<any[]> {\r\n  try {\r\n    let query = supabase\r\n      .from('credential_audit_log')\r\n      .select('*')\r\n      .eq('workspace_id', workspaceId)\r\n      .order('created_at', { ascending: false })\r\n\r\n    if (filters?.platform) {\r\n      query = query.eq('platform', filters.platform)\r\n    }\r\n\r\n    if (filters?.action) {\r\n      query = query.eq('action', filters.action)\r\n    }\r\n\r\n    if (filters?.status) {\r\n      query = query.eq('status', filters.status)\r\n    }\r\n\r\n    if (filters?.startDate) {\r\n      query = query.gte('created_at', filters.startDate.toISOString())\r\n    }\r\n\r\n    if (filters?.endDate) {\r\n      query = query.lte('created_at', filters.endDate.toISOString())\r\n    }\r\n\r\n    const limit = Math.min(filters?.limit || 100, 1000) // Cap at 1000\r\n    const offset = filters?.offset || 0\r\n\r\n    query = query.range(offset, offset + limit - 1)\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) throw error\r\n    return data || []\r\n  } catch (error) {\r\n    console.error('Error fetching audit logs:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Get audit logs for a specific user\r\n */\r\nexport async function getUserAuditLogs(\r\n  workspaceId: string,\r\n  userId: string,\r\n  options?: {\r\n    limit?: number\r\n    offset?: number\r\n  }\r\n): Promise<any[]> {\r\n  try {\r\n    let query = supabase\r\n      .from('credential_audit_log')\r\n      .select('*')\r\n      .eq('workspace_id', workspaceId)\r\n      .eq('user_id', userId)\r\n      .order('created_at', { ascending: false })\r\n\r\n    const limit = Math.min(options?.limit || 50, 500)\r\n    const offset = options?.offset || 0\r\n\r\n    query = query.range(offset, offset + limit - 1)\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) throw error\r\n    return data || []\r\n  } catch (error) {\r\n    console.error('Error fetching user audit logs:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Get summary of credential activities\r\n */\r\nexport async function getAuditSummary(\r\n  workspaceId: string,\r\n  days: number = 7\r\n): Promise<{\r\n  totalConnections: number\r\n  totalDisconnections: number\r\n  totalRefreshes: number\r\n  totalFailures: number\r\n  platformStats: Record<string, any>\r\n  recentActivity: any[]\r\n}> {\r\n  try {\r\n    const startDate = new Date()\r\n    startDate.setDate(startDate.getDate() - days)\r\n\r\n    const logs = await getAuditLogs(workspaceId, {\r\n      startDate,\r\n      limit: 1000,\r\n    })\r\n\r\n    const summary = {\r\n      totalConnections: 0,\r\n      totalDisconnections: 0,\r\n      totalRefreshes: 0,\r\n      totalFailures: 0,\r\n      platformStats: {\r\n        twitter: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        linkedin: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        facebook: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        instagram: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n      },\r\n      recentActivity: logs.slice(0, 10),\r\n    }\r\n\r\n    for (const log of logs) {\r\n      if (log.status === 'failed') {\r\n        summary.totalFailures++\r\n        ;(summary.platformStats as any)[(log as any).platform].failures++\r\n      }\r\n\r\n      if (log.action === 'platform_connected') {\r\n        summary.totalConnections++\r\n        ;(summary.platformStats as any)[(log as any).platform].connections++\r\n      } else if (log.action === 'platform_disconnected') {\r\n        summary.totalDisconnections++\r\n        ;(summary.platformStats as any)[(log as any).platform].disconnections++\r\n      } else if (log.action === 'token_refreshed') {\r\n        summary.totalRefreshes++\r\n        ;(summary.platformStats as any)[(log as any).platform].refreshes++\r\n      }\r\n    }\r\n\r\n    return summary\r\n  } catch (error) {\r\n    console.error('Error getting audit summary:', error)\r\n    return {\r\n      totalConnections: 0,\r\n      totalDisconnections: 0,\r\n      totalRefreshes: 0,\r\n      totalFailures: 0,\r\n      platformStats: {\r\n        twitter: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        linkedin: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        facebook: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        instagram: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n      },\r\n      recentActivity: [],\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up old audit logs (older than 90 days)\r\n */\r\nexport async function cleanupOldAuditLogs(): Promise<number> {\r\n  try {\r\n    const ninetyDaysAgo = new Date()\r\n    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90)\r\n\r\n    const { data, error } = await supabase\r\n      .from('credential_audit_log')\r\n      .delete()\r\n      .lt('created_at', ninetyDaysAgo.toISOString())\r\n      .select('id')\r\n\r\n    if (error) throw error\r\n\r\n    return data?.length || 0\r\n  } catch (error) {\r\n    console.error('Error cleaning up audit logs:', error)\r\n    return 0\r\n  }\r\n}\r\n\r\n// ============================================\r\n// WORKSPACE-SPECIFIC AUDIT LOGGING\r\n// ============================================\r\n\r\nexport type WorkspaceAuditAction =\r\n  | 'member_invited'        // When someone sends an invite\r\n  | 'member_joined'         // When someone accepts invite\r\n  | 'member_removed'        // When admin removes a member\r\n  | 'member_role_changed'   // When admin changes member's role\r\n  | 'workspace_updated'     // When workspace settings change\r\n  | 'invite_revoked'        // When admin cancels an invite\r\n\r\nexport interface WorkspaceAuditLogParams {\r\n  workspaceId: string\r\n  userId: string\r\n  action: WorkspaceAuditAction\r\n  entityType: string\r\n  entityId: string\r\n  details: Record<string, any>\r\n}\r\n\r\n/**\r\n * Log workspace-related actions for audit trail\r\n * Used for: member invitations, role changes, removals, etc.\r\n *\r\n * @param params - Audit log parameters\r\n * @throws Errors are logged but not thrown to prevent breaking operations\r\n */\r\nexport async function logWorkspaceAction({\r\n  workspaceId,\r\n  userId,\r\n  action,\r\n  entityType,\r\n  entityId,\r\n  details,\r\n}: WorkspaceAuditLogParams): Promise<void> {\r\n  try {\r\n    const { error } = await (supabase.from('audit_logs') as any).insert({\r\n      workspace_id: workspaceId,\r\n      user_id: userId,\r\n      action,\r\n      entity_type: entityType,\r\n      entity_id: entityId,\r\n      details,\r\n      created_at: new Date().toISOString(),\r\n    })\r\n\r\n    if (error) {\r\n      console.error(`Failed to log workspace action \"${action}\":`, error)\r\n    }\r\n  } catch (error) {\r\n    console.error('Workspace audit logging error:', error)\r\n    // Don't throw - logging failures shouldn't break the app\r\n  }\r\n}\r\n\r\n/**\r\n * Get workspace activity log with filters\r\n *\r\n * @param workspaceId - Workspace to get activity for\r\n * @param filters - Optional filters for activity type, user, date range\r\n * @returns Paginated activity logs with total count\r\n */\r\nexport async function getWorkspaceActivityLog(\r\n  workspaceId: string,\r\n  filters?: {\r\n    userId?: string\r\n    action?: WorkspaceAuditAction\r\n    startDate?: Date\r\n    endDate?: Date\r\n    limit?: number\r\n    offset?: number\r\n  }\r\n): Promise<{\r\n  data: any[]\r\n  total: number\r\n  limit: number\r\n  offset: number\r\n  hasMore: boolean\r\n}> {\r\n  try {\r\n    // Build the query\r\n    let query = supabase\r\n      .from('audit_logs')\r\n      .select(\r\n        `\r\n        id,\r\n        workspace_id,\r\n        user_id,\r\n        action,\r\n        entity_type,\r\n        entity_id,\r\n        details,\r\n        created_at,\r\n        users:user_id (\r\n          email,\r\n          full_name\r\n        )\r\n      `,\r\n        { count: 'exact' }\r\n      )\r\n      .eq('workspace_id', workspaceId)\r\n      .order('created_at', { ascending: false })\r\n\r\n    // Apply filters\r\n    if (filters?.userId) {\r\n      query = query.eq('user_id', filters.userId)\r\n    }\r\n\r\n    if (filters?.action) {\r\n      query = query.eq('action', filters.action)\r\n    }\r\n\r\n    if (filters?.startDate) {\r\n      query = query.gte('created_at', filters.startDate.toISOString())\r\n    }\r\n\r\n    if (filters?.endDate) {\r\n      query = query.lte('created_at', filters.endDate.toISOString())\r\n    }\r\n\r\n    // Pagination\r\n    const limit = Math.min(filters?.limit || 50, 500) // Cap at 500\r\n    const offset = filters?.offset || 0\r\n    query = query.range(offset, offset + limit - 1)\r\n\r\n    const { data, error, count } = await query\r\n\r\n    if (error) {\r\n      console.error('Error fetching workspace activity log:', error)\r\n      throw error\r\n    }\r\n\r\n    return {\r\n      data: data || [],\r\n      total: count || 0,\r\n      limit,\r\n      offset,\r\n      hasMore: (count || 0) > offset + limit,\r\n    }\r\n  } catch (error) {\r\n    console.error('Error getting workspace activity log:', error)\r\n    return {\r\n      data: [],\r\n      total: 0,\r\n      limit: filters?.limit || 50,\r\n      offset: filters?.offset || 0,\r\n      hasMore: false,\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Server-side Credential Service\r\n * Single source of truth for credentials (database-backed only)\r\n * Proper encryption/decryption with workspace-specific keys\r\n * Token refresh handling\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport {\r\n  encryptCredentials,\r\n  decryptCredentials,\r\n  getOrCreateWorkspaceEncryptionKey,\r\n} from '@/lib/auth/encryptionManager'\r\nimport { logAuditEvent } from './auditLogService'\r\nimport type { Platform } from '@/types'\r\n\r\nexport class CredentialService {\r\n  /**\r\n   * Save platform credentials to database\r\n   * Encrypts using workspace-specific key\r\n   */\r\n  static async savePlatformCredentials(\r\n    platform: Platform,\r\n    credentials: any,\r\n    userId: string,\r\n    workspaceId: string,\r\n    options: { pageId?: string; pageName?: string } = {}\r\n  ): Promise<void> {\r\n    try {\r\n      // Get encryption key for this workspace\r\n      const encryptionKey = await getOrCreateWorkspaceEncryptionKey(workspaceId)\r\n\r\n      // Encrypt credentials\r\n      const encryptedData = await encryptCredentials(credentials, encryptionKey)\r\n\r\n      // Check if already exists\r\n      const { data: existing, error: checkError } = await supabase\r\n        .from('social_accounts')\r\n        .select('id')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('platform', platform)\r\n        .maybeSingle()\r\n\r\n      if (checkError) throw checkError\r\n\r\n      // Prepare common data\r\n      const commonData = {\r\n        credentials_encrypted: encryptedData,\r\n        is_connected: credentials.isConnected ?? true,\r\n        username: credentials.username || null,\r\n        expires_at: credentials.expiresAt || null,\r\n        last_refreshed_at: new Date().toISOString(),\r\n        refresh_token_encrypted: credentials.refreshToken\r\n          ? await encryptCredentials(\r\n              { token: credentials.refreshToken },\r\n              encryptionKey\r\n            )\r\n          : null,\r\n        page_id: options.pageId || null,\r\n        page_name: options.pageName || null,\r\n        connected_at: credentials.isConnected ? new Date().toISOString() : null,\r\n        refresh_error_count: 0,\r\n      }\r\n\r\n      if (existing) {\r\n        // Update existing\r\n        const { error: updateError } = await (supabase\r\n          .from('social_accounts') as any)\r\n          .update(commonData)\r\n          .eq('id', (existing as any).id)\r\n\r\n        if (updateError) throw updateError\r\n\r\n        // Log audit\r\n        await logAuditEvent({\r\n          workspaceId,\r\n          userId,\r\n          platform,\r\n          action: 'credentials_updated',\r\n          status: 'success',\r\n        })\r\n      } else {\r\n        // Insert new\r\n        const { error: insertError } = await (supabase.from('social_accounts') as any).insert({\r\n          workspace_id: workspaceId,\r\n          platform,\r\n          ...commonData,\r\n        })\r\n\r\n        if (insertError) throw insertError\r\n\r\n        await logAuditEvent({\r\n          workspaceId,\r\n          userId,\r\n          platform,\r\n          action: 'platform_connected',\r\n          status: 'success',\r\n        })\r\n      }\r\n    } catch (error) {\r\n      console.error('Error saving credentials:', error)\r\n\r\n      await logAuditEvent({\r\n        workspaceId,\r\n        userId,\r\n        platform,\r\n        action: 'credentials_save_failed',\r\n        status: 'failed',\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        errorCode: 'SAVE_ERROR',\r\n      }).catch(err => console.error('Failed to log error:', err))\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get credentials for a specific platform\r\n   */\r\n  static async getPlatformCredentials(\r\n    platform: Platform,\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<any | null> {\r\n    try {\r\n      const { data, error } = await (supabase\r\n        .from('social_accounts') as any)\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('platform', platform)\r\n        .maybeSingle()\r\n\r\n      if (error || !data) return null\r\n\r\n      // Decrypt credentials\r\n      const encryptionKey = await getOrCreateWorkspaceEncryptionKey(workspaceId)\r\n      const credentials = await decryptCredentials((data as any).credentials_encrypted, encryptionKey)\r\n\r\n      // Decrypt refresh token if exists\r\n      let refreshToken = null\r\n      if ((data as any).refresh_token_encrypted) {\r\n        try {\r\n          const decryptedRefresh = await decryptCredentials(\r\n            (data as any).refresh_token_encrypted,\r\n            encryptionKey\r\n          )\r\n          refreshToken = decryptedRefresh.token\r\n        } catch (err) {\r\n          console.error('Failed to decrypt refresh token:', err)\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...credentials,\r\n        refreshToken,\r\n        expiresAt: (data as any).expires_at,\r\n        pageId: (data as any).page_id,\r\n        pageName: (data as any).page_name,\r\n        isConnected: (data as any).is_connected,\r\n      }\r\n    } catch (error) {\r\n      console.error('Error getting credentials:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify and refresh token if needed\r\n   */\r\n  static async verifyAndRefreshToken(\r\n    platform: Platform,\r\n    userId: string,\r\n    workspaceId: string,\r\n    refreshFunction?: (credentials: any) => Promise<any>\r\n  ): Promise<any> {\r\n    try {\r\n      const credentials = await this.getPlatformCredentials(platform, userId, workspaceId)\r\n\r\n      if (!credentials) {\r\n        throw new Error(`No credentials found for ${platform}`)\r\n      }\r\n\r\n      // Check if token is expired\r\n      if (credentials.expiresAt) {\r\n        const expiresAt = new Date(credentials.expiresAt).getTime()\r\n        const now = Date.now()\r\n\r\n        if (now > expiresAt) {\r\n          // Token expired, try to refresh\r\n          if (refreshFunction && credentials.refreshToken) {\r\n            try {\r\n              const newCredentials = await refreshFunction(credentials)\r\n\r\n              // Save refreshed credentials\r\n              await this.savePlatformCredentials(\r\n                platform,\r\n                newCredentials,\r\n                userId,\r\n                workspaceId\r\n              )\r\n\r\n              await logAuditEvent({\r\n                workspaceId,\r\n                userId,\r\n                platform,\r\n                action: 'token_refreshed',\r\n                status: 'success',\r\n              })\r\n\r\n              return newCredentials\r\n            } catch (refreshError) {\r\n              await logAuditEvent({\r\n                workspaceId,\r\n                userId,\r\n                platform,\r\n                action: 'token_refresh_failed',\r\n                status: 'failed',\r\n                errorMessage:\r\n                  refreshError instanceof Error ? refreshError.message : String(refreshError),\r\n                errorCode: 'REFRESH_ERROR',\r\n              })\r\n\r\n              throw new Error(\r\n                `Token refresh failed: ${\r\n                  refreshError instanceof Error ? refreshError.message : String(refreshError)\r\n                }`\r\n              )\r\n            }\r\n          } else {\r\n            throw new Error('Token expired and no refresh token available')\r\n          }\r\n        }\r\n      }\r\n\r\n      return credentials\r\n    } catch (error) {\r\n      console.error('Token verification failed:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect platform\r\n   */\r\n  static async disconnectPlatform(\r\n    platform: Platform,\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      const { error } = await (supabase\r\n        .from('social_accounts') as any)\r\n        .update({\r\n          is_connected: false,\r\n          credentials_encrypted: null,\r\n          refresh_token_encrypted: null,\r\n          connected_at: null,\r\n        })\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('platform', platform)\r\n\r\n      if (error) throw error\r\n\r\n      await logAuditEvent({\r\n        workspaceId,\r\n        userId,\r\n        platform,\r\n        action: 'platform_disconnected',\r\n        status: 'success',\r\n      })\r\n    } catch (error) {\r\n      console.error('Error disconnecting platform:', error)\r\n\r\n      await logAuditEvent({\r\n        workspaceId,\r\n        userId,\r\n        platform,\r\n        action: 'disconnect_failed',\r\n        status: 'failed',\r\n        errorMessage: error instanceof Error ? error.message : String(error),\r\n        errorCode: 'DISCONNECT_ERROR',\r\n      }).catch(err => console.error('Failed to log error:', err))\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get connection status for all platforms\r\n   */\r\n  static async getConnectionStatus(\r\n    workspaceId: string\r\n  ): Promise<Record<Platform, any>> {\r\n    try {\r\n      const { data, error } = await (supabase\r\n        .from('social_accounts') as any)\r\n        .select('platform, is_connected, username, page_name, expires_at')\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n\r\n      const status: Record<string, any> = {\r\n        twitter: { isConnected: false },\r\n        linkedin: { isConnected: false },\r\n        facebook: { isConnected: false },\r\n        instagram: { isConnected: false },\r\n      }\r\n\r\n      const now = Date.now()\r\n      const oneDayMs = 1000 * 60 * 60 * 24\r\n\r\n      for (const account of data || []) {\r\n        const expiresAt: number | null = ((account as any).expires_at\r\n          ? new Date((account as any).expires_at).getTime()\r\n          : null) as number | null\r\n\r\n        (status as any)[(account as any).platform] = {\r\n          isConnected: (account as any).is_connected,\r\n          username: (account as any).username || (account as any).page_name,\r\n          expiresAt: (account as any).expires_at,\r\n          isExpiringSoon:\r\n            expiresAt && expiresAt - now < oneDayMs && expiresAt > now,\r\n          isExpired: expiresAt && expiresAt <= now,\r\n        }\r\n      }\r\n\r\n      return status\r\n    } catch (error) {\r\n      console.error('Error getting connection status:', error)\r\n      return {\r\n        twitter: { isConnected: false },\r\n        linkedin: { isConnected: false },\r\n        facebook: { isConnected: false },\r\n        instagram: { isConnected: false },\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete platform credentials completely\r\n   */\r\n  static async deletePlatformCredentials(\r\n    platform: Platform,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      const { error } = await (supabase\r\n        .from('social_accounts') as any)\r\n        .delete()\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('platform', platform)\r\n\r\n      if (error) throw error\r\n    } catch (error) {\r\n      console.error('Error deleting credentials:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all connection statuses\r\n   */\r\n  static async getAllCredentialsStatus(\r\n    workspaceId: string\r\n  ): Promise<Array<{ platform: Platform; isConnected: boolean; username?: string }>> {\r\n    try {\r\n      const { data, error } = await (supabase\r\n        .from('social_accounts') as any)\r\n        .select('platform, is_connected, username, page_name')\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n\r\n      return (data || []).map((account: any) => ({\r\n        platform: account.platform as Platform,\r\n        isConnected: account.is_connected,\r\n        username: account.username || account.page_name,\r\n      }))\r\n    } catch (error) {\r\n      console.error('Error getting all credentials status:', error)\r\n      return []\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Server-side Encryption Manager\r\n * Handles all encryption/decryption operations\r\n * Keys are NEVER sent to client\r\n * Uses Node.js crypto module for secure operations\r\n */\r\n\r\nimport crypto from 'crypto'\r\n\r\n/**\r\n * Get or create workspace encryption key\r\n * Derives a key from master secret + workspace ID\r\n */\r\nexport async function getOrCreateWorkspaceEncryptionKey(\r\n  workspaceId: string\r\n): Promise<Buffer> {\r\n  try {\r\n    const masterSecret = process.env.ENCRYPTION_MASTER_KEY\r\n\r\n    if (!masterSecret) {\r\n      throw new Error('ENCRYPTION_MASTER_KEY environment variable not set')\r\n    }\r\n\r\n    // Derive a workspace-specific key using PBKDF2\r\n    const key = crypto.pbkdf2Sync(\r\n      masterSecret, // password\r\n      workspaceId, // salt\r\n      100000, // iterations\r\n      32, // keylen (256 bits for AES-256)\r\n      'sha256'\r\n    )\r\n\r\n    return key\r\n  } catch (error) {\r\n    console.error('Failed to get workspace encryption key:', error)\r\n    throw new Error('Encryption key unavailable')\r\n  }\r\n}\r\n\r\n/**\r\n * Encrypt credentials using AES-256-GCM\r\n * Returns base64-encoded string with IV + ciphertext\r\n */\r\nexport async function encryptCredentials(\r\n  credentials: any,\r\n  encryptionKey: Buffer\r\n): Promise<string> {\r\n  try {\r\n    const data = JSON.stringify(credentials)\r\n\r\n    // Generate random IV (12 bytes for GCM)\r\n    const iv = crypto.randomBytes(12)\r\n\r\n    // Create cipher\r\n    const cipher = crypto.createCipheriv('aes-256-gcm', encryptionKey, iv)\r\n\r\n    // Encrypt data\r\n    let encrypted = cipher.update(data, 'utf8', 'hex')\r\n    encrypted += cipher.final('hex')\r\n\r\n    // Get authentication tag\r\n    const authTag = cipher.getAuthTag()\r\n\r\n    // Combine IV + authTag + encrypted data\r\n    const combined = Buffer.concat([iv, authTag, Buffer.from(encrypted, 'hex')])\r\n\r\n    // Return as base64\r\n    return combined.toString('base64')\r\n  } catch (error) {\r\n    console.error('Encryption failed:', error)\r\n    throw new Error('Failed to encrypt credentials')\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt credentials using AES-256-GCM\r\n */\r\nexport async function decryptCredentials(\r\n  encryptedData: string,\r\n  encryptionKey: Buffer\r\n): Promise<any> {\r\n  try {\r\n    // Decode from base64\r\n    const combined = Buffer.from(encryptedData, 'base64')\r\n\r\n    // Extract IV (first 12 bytes), authTag (next 16 bytes), and ciphertext\r\n    const iv = combined.slice(0, 12)\r\n    const authTag = combined.slice(12, 28)\r\n    const ciphertext = combined.slice(28)\r\n\r\n    // Create decipher\r\n    const decipher = crypto.createDecipheriv('aes-256-gcm', encryptionKey, iv)\r\n\r\n    // Set authentication tag\r\n    decipher.setAuthTag(authTag)\r\n\r\n    // Decrypt\r\n    let decrypted = decipher.update(ciphertext.toString('hex'), 'hex', 'utf8')\r\n    decrypted += decipher.final('utf8')\r\n\r\n    return JSON.parse(decrypted)\r\n  } catch (error) {\r\n    console.error('Decryption failed:', error)\r\n    throw new Error('Failed to decrypt credentials')\r\n  }\r\n}\r\n\r\n/**\r\n * Hash a value using SHA-256\r\n */\r\nexport function hashValue(value: string): string {\r\n  return crypto.createHash('sha256').update(value).digest('hex')\r\n}\r\n\r\n/**\r\n * Generate random bytes\r\n */\r\nexport function generateRandomBytes(length: number = 32): string {\r\n  return crypto.randomBytes(length).toString('hex')\r\n}\r\n","/**\r\n * Post Service - Supabase Database Operations\r\n * Handles all CRUD operations for posts\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport { Post, PostStatus, Platform } from '@/types'\r\n\r\nexport class PostService {\r\n  /**\r\n   * Get all posts for the current user's workspace\r\n   */\r\n  static async getAllPosts(workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      // Transform database format to app format\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching posts:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a single post by ID\r\n   */\r\n  static async getPostById(postId: string, workspaceId: string): Promise<Post | null> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('id', postId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return data ? this.transformFromDB(data) : null\r\n    } catch (error) {\r\n      console.error('Error fetching post:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new post\r\n   */\r\n  static async createPost(post: Post, userId: string, workspaceId: string): Promise<Post> {\r\n    try {\r\n      const dbPost = this.transformToDB(post, userId, workspaceId)\r\n\r\n      const { data, error } = await supabase\n        .from('posts')\n        .insert(dbPost)\n        .select()\n        .maybeSingle<{ id: string }>()\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'create', 'post', data!.id)\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error creating post:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update an existing post\r\n   */\r\n  static async updatePost(post: Post, userId: string, workspaceId: string): Promise<Post> {\r\n    try {\r\n      const dbPost = this.transformToDB(post, userId, workspaceId)\r\n\r\n      const { data, error } = await (supabase.from('posts') as any)\n        .update(dbPost)\n        .eq('id', post.id)\n        .eq('workspace_id', workspaceId)\n        .select()\n        .single()\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'update', 'post', (data as any).id)\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error updating post:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a post\r\n   */\r\n  static async deletePost(postId: string, userId: string, workspaceId: string): Promise<void> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('posts')\r\n        .delete()\r\n        .eq('id', postId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'delete', 'post', postId)\r\n    } catch (error) {\r\n      console.error('Error deleting post:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get posts by status\r\n   */\r\n  static async getPostsByStatus(status: PostStatus, workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('status', status)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching posts by status:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get posts by campaign\r\n   */\r\n  static async getPostsByCampaign(campaignId: string, workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('campaign_id', campaignId)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching posts by campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get scheduled posts (for publishing)\r\n   */\r\n  static async getScheduledPosts(workspaceId: string): Promise<Post[]> {\r\n    try {\r\n      const now = new Date().toISOString()\r\n\r\n      const { data, error } = await supabase\r\n        .from('posts')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .eq('status', 'scheduled')\r\n        .lte('scheduled_at', now)\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching scheduled posts:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update post status\r\n   */\r\n  static async updatePostStatus(\r\n    postId: string,\r\n    status: PostStatus,\r\n    userId: string,\r\n    workspaceId: string\r\n  ): Promise<void> {\r\n    try {\r\n      const updateData: any = { status }\r\n\r\n      // Add published_at timestamp when status is published\r\n      if (status === 'published') {\r\n        updateData.published_at = new Date().toISOString()\r\n      }\r\n\r\n      const { error } = await (supabase.from('posts') as any)\n        .update(updateData)\n        .eq('id', postId)\n        .eq('workspace_id', workspaceId)\n\r\n      if (error) throw error\r\n\r\n      // Log activity\r\n      await this.logActivity(workspaceId, userId, 'update_status', 'post', postId, { status })\r\n    } catch (error) {\r\n      console.error('Error updating post status:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform database row to Post type\r\n   */\r\n  private static transformFromDB(dbPost: any): Post {\r\n    return {\r\n      id: dbPost.id,\r\n      topic: dbPost.topic,\r\n      platforms: dbPost.platforms as Platform[],\r\n      content: dbPost.content,\r\n      status: dbPost.status as PostStatus,\r\n      createdAt: dbPost.created_at,\r\n      scheduledAt: dbPost.scheduled_at,\r\n      publishedAt: dbPost.published_at,\r\n      campaignId: dbPost.campaign_id,\r\n      engagementScore: dbPost.engagement_score,\r\n      engagementSuggestions: dbPost.engagement_suggestions,\r\n      // These fields are stored in content JSONB\r\n      generatedImage: dbPost.content?.generatedImage,\r\n      generatedVideoUrl: dbPost.content?.generatedVideoUrl,\r\n      isGeneratingImage: dbPost.content?.isGeneratingImage || false,\r\n      isGeneratingVideo: dbPost.content?.isGeneratingVideo || false,\r\n      videoGenerationStatus: dbPost.content?.videoGenerationStatus,\r\n      videoOperation: dbPost.content?.videoOperation,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform Post type to database format\r\n   */\r\n  private static transformToDB(post: Post, userId: string, workspaceId: string): any {\r\n    // Extract fields that go into content JSONB\r\n    const { generatedImage, generatedVideoUrl, isGeneratingImage, isGeneratingVideo, videoGenerationStatus, videoOperation, content, ...rest } = post\r\n\r\n    return {\r\n      id: post.id,\r\n      workspace_id: workspaceId,\r\n      created_by: userId,\r\n      topic: post.topic,\r\n      platforms: post.platforms,\r\n      content: {\r\n        ...content,\r\n        generatedImage,\r\n        generatedVideoUrl,\r\n        isGeneratingImage,\r\n        isGeneratingVideo,\r\n        videoGenerationStatus,\r\n        videoOperation,\r\n      },\r\n      status: post.status,\r\n      scheduled_at: post.scheduledAt,\r\n      published_at: post.publishedAt,\r\n      campaign_id: post.campaignId,\r\n      engagement_score: post.engagementScore,\r\n      engagement_suggestions: post.engagementSuggestions,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log activity to activity_logs table\r\n   */\r\n  private static async logActivity(\r\n    workspaceId: string,\r\n    userId: string,\r\n    action: string,\r\n    resourceType: string,\r\n    resourceId: string,\r\n    details: any = {}\r\n  ): Promise<void> {\r\n    try {\r\n      await (supabase.from('activity_logs') as any).insert({\n        workspace_id: workspaceId,\n        user_id: userId,\n        action,\n        resource_type: resourceType,\n        resource_id: resourceId,\n        details: details || null,\n      })\n    } catch (error) {\r\n      console.error('Error logging activity:', error)\r\n      // Don't throw - activity logging shouldn't break the main operation\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Campaign Service - Supabase Database Operations\r\n * Handles all CRUD operations for campaigns\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport { Campaign } from '@/types'\nimport type { Database } from '@/lib/supabase/types'\n\r\nexport class CampaignService {\r\n  /**\r\n   * Get all campaigns for workspace\r\n   */\r\n  static async getAllCampaigns(workspaceId: string): Promise<Campaign[]> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('campaigns')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) throw error\r\n\r\n      return data.map(this.transformFromDB)\r\n    } catch (error) {\r\n      console.error('Error fetching campaigns:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get campaign by ID\r\n   */\r\n  static async getCampaignById(campaignId: string, workspaceId: string): Promise<Campaign | null> {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('campaigns')\r\n        .select('*')\r\n        .eq('id', campaignId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (error) throw error\r\n\r\n      return data ? this.transformFromDB(data) : null\r\n    } catch (error) {\r\n      console.error('Error fetching campaign:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new campaign\r\n   */\r\n  static async createCampaign(\r\n    workspaceId: string,\r\n    name: string,\r\n    description?: string,\r\n    startDate?: string,\r\n    endDate?: string,\r\n    goals?: string[]\r\n  ): Promise<Campaign> {\r\n    try {\r\n      const campaign: Database['public']['Tables']['campaigns']['Insert'] = {\n        workspace_id: workspaceId,\n        name,\n        goal: description || null,\n        color: this.getRandomCampaignColor(),\n        start_date: startDate || new Date().toISOString(),\n        end_date: endDate || null,\n      }\n\r\n      const { data, error } = await (supabase\n        .from('campaigns') as any)\n        .insert(campaign)\n        .select()\n        .single()\n\r\n      if (error) throw error\r\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error creating campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a campaign\r\n   */\r\n  static async updateCampaign(campaign: Campaign, workspaceId: string): Promise<Campaign> {\r\n    try {\r\n      const dbCampaign = {\n        name: campaign.name,\n        goal: campaign.description || null,\n        color: campaign.color,\n        start_date: campaign.startDate,\n        end_date: campaign.endDate ?? null,\n      }\n\r\n      const { data, error } = await (supabase\n        .from('campaigns') as any)\n        .update(dbCampaign)\n        .eq('id', campaign.id)\n        .eq('workspace_id', workspaceId)\n        .select()\n        .single()\n\r\n      if (error) throw error\r\n\r\n      return this.transformFromDB(data)\r\n    } catch (error) {\r\n      console.error('Error updating campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a campaign\r\n   */\r\n  static async deleteCampaign(campaignId: string, workspaceId: string): Promise<void> {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('campaigns')\r\n        .delete()\r\n        .eq('id', campaignId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n    } catch (error) {\r\n      console.error('Error deleting campaign:', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get posts count for a campaign\r\n   */\r\n  static async getCampaignPostsCount(campaignId: string, workspaceId: string): Promise<number> {\r\n    try {\r\n      const { count, error } = await supabase\r\n        .from('posts')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('campaign_id', campaignId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) throw error\r\n\r\n      return count || 0\r\n    } catch (error) {\r\n      console.error('Error getting campaign posts count:', error)\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform database row to Campaign type\r\n   */\r\n  private static transformFromDB(dbCampaign: any): Campaign {\n    return {\n      id: dbCampaign.id,\n      name: dbCampaign.name,\n      description: dbCampaign.goal,\n      color: dbCampaign.color,\n      startDate: dbCampaign.start_date,\n      endDate: dbCampaign.end_date,\n      createdAt: dbCampaign.created_at,\n    }\n  }\n\r\n  /**\r\n   * Generate random campaign color\r\n   */\r\n  private static getRandomCampaignColor(): string {\r\n    const colors = [\r\n      '#8B5CF6', // Purple\r\n      '#EC4899', // Pink\r\n      '#F59E0B', // Amber\r\n      '#10B981', // Green\r\n      '#3B82F6', // Blue\r\n      '#EF4444', // Red\r\n      '#14B8A6', // Teal\r\n      '#F97316', // Orange\r\n    ]\r\n    return colors[Math.floor(Math.random() * colors.length)]\r\n  }\r\n}\r\n","/**\r\n * Database Services - Centralized exports\r\n */\r\n\r\nexport { PostService } from './postService'\r\nexport { CampaignService } from './campaignService'\r\nexport { CredentialService } from './credentialService'\r\nexport { MigrationService } from './migrationService'\r\n","/**\r\n * Migration Service\r\n * Handles one-time migration of data from localStorage to Supabase\r\n */\r\n\r\nimport { PostService } from './postService'\r\nimport { CampaignService } from './campaignService'\r\nimport { CredentialService } from './credentialService'\r\nimport { Post, Campaign, PlatformCredentials } from '@/types'\r\n\r\nexport class MigrationService {\r\n  /**\r\n   * Check if migration is needed\r\n   */\r\n  static needsMigration(): boolean {\r\n    // Check if there's data in localStorage\r\n    const hasPosts = localStorage.getItem('socialMediaPosts') !== null\r\n    const hasCampaigns = localStorage.getItem('campaigns') !== null\r\n    const hasCredentials = localStorage.getItem('social_media_credentials') !== null\r\n\r\n    // Check if migration has been completed before\r\n    const migrationCompleted = localStorage.getItem('migration_completed') === 'true'\r\n\r\n    return (hasPosts || hasCampaigns || hasCredentials) && !migrationCompleted\r\n  }\r\n\r\n  /**\r\n   * Migrate all data from localStorage to Supabase\r\n   */\r\n  static async migrateAllData(userId: string, workspaceId: string): Promise<{\r\n    success: boolean\r\n    postsCount: number\r\n    campaignsCount: number\r\n    credentialsCount: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let postsCount = 0\r\n    let campaignsCount = 0\r\n    let credentialsCount = 0\r\n\r\n    try {\r\n      // Migrate posts\r\n      const postsMigrationResult = await this.migratePosts(userId, workspaceId)\r\n      postsCount = postsMigrationResult.count\r\n      if (postsMigrationResult.errors.length > 0) {\r\n        errors.push(...postsMigrationResult.errors)\r\n      }\r\n\r\n      // Migrate campaigns\r\n      const campaignsMigrationResult = await this.migrateCampaigns(workspaceId)\r\n      campaignsCount = campaignsMigrationResult.count\r\n      if (campaignsMigrationResult.errors.length > 0) {\r\n        errors.push(...campaignsMigrationResult.errors)\r\n      }\r\n\r\n      // Migrate credentials\r\n      const credentialsMigrationResult = await this.migrateCredentials(userId, workspaceId)\r\n      credentialsCount = credentialsMigrationResult.count\r\n      if (credentialsMigrationResult.errors.length > 0) {\r\n        errors.push(...credentialsMigrationResult.errors)\r\n      }\r\n\r\n      // Mark migration as completed\r\n      localStorage.setItem('migration_completed', 'true')\r\n\r\n      return {\r\n        success: errors.length === 0,\r\n        postsCount,\r\n        campaignsCount,\r\n        credentialsCount,\r\n        errors,\r\n      }\r\n    } catch (error) {\r\n      console.error('Migration error:', error)\r\n      errors.push('Failed to complete migration: ' + (error as Error).message)\r\n      return {\r\n        success: false,\r\n        postsCount,\r\n        campaignsCount,\r\n        credentialsCount,\r\n        errors,\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Migrate posts from localStorage\r\n   */\r\n  private static async migratePosts(userId: string, workspaceId: string): Promise<{\r\n    count: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let count = 0\r\n\r\n    try {\r\n      const postsJson = localStorage.getItem('socialMediaPosts')\r\n      if (!postsJson) return { count: 0, errors: [] }\r\n\r\n      const posts: Post[] = JSON.parse(postsJson)\r\n\r\n      for (const post of posts) {\r\n        try {\r\n          // Check if post already exists in database\r\n          const existing = await PostService.getPostById(post.id, workspaceId)\r\n          if (existing) {\r\n            console.log(`Post ${post.id} already exists, skipping`)\r\n            continue\r\n          }\r\n\r\n          await PostService.createPost(post, userId, workspaceId)\r\n          count++\r\n        } catch (error) {\r\n          console.error(`Error migrating post ${post.id}:`, error)\r\n          errors.push(`Failed to migrate post \"${post.topic}\": ${(error as Error).message}`)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing posts from localStorage:', error)\r\n      errors.push('Failed to parse posts from localStorage')\r\n    }\r\n\r\n    return { count, errors }\r\n  }\r\n\r\n  /**\r\n   * Migrate campaigns from localStorage\r\n   */\r\n  private static async migrateCampaigns(workspaceId: string): Promise<{\r\n    count: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let count = 0\r\n\r\n    try {\r\n      const campaignsJson = localStorage.getItem('campaigns')\r\n      if (!campaignsJson) return { count: 0, errors: [] }\r\n\r\n      const campaigns: Campaign[] = JSON.parse(campaignsJson)\r\n\r\n      for (const campaign of campaigns) {\r\n        try {\r\n          // Check if campaign already exists\r\n          const existing = await CampaignService.getCampaignById(campaign.id, workspaceId)\r\n          if (existing) {\r\n            console.log(`Campaign ${campaign.id} already exists, skipping`)\r\n            continue\r\n          }\r\n\r\n          // Create campaign directly with ID preservation\r\n          const { error } = await (await import('@/lib/supabase')).supabase\r\n            .from('campaigns' as any)\r\n            .insert({\r\n              id: campaign.id, // Preserve original ID\r\n              workspace_id: workspaceId,\r\n              name: campaign.name,\r\n              goal: campaign.description || null,\r\n              color: campaign.color,\r\n              start_date: campaign.startDate,\r\n              end_date: campaign.endDate ?? null,\r\n            } as any)\r\n\r\n          if (error) throw error\r\n\r\n          count++\r\n        } catch (error) {\r\n          console.error(`Error migrating campaign ${campaign.id}:`, error)\r\n          errors.push(`Failed to migrate campaign \"${campaign.name}\": ${(error as Error).message}`)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing campaigns from localStorage:', error)\r\n      errors.push('Failed to parse campaigns from localStorage')\r\n    }\r\n\r\n    return { count, errors }\r\n  }\r\n\r\n  /**\r\n   * Migrate credentials from localStorage\r\n   */\r\n  private static async migrateCredentials(userId: string, workspaceId: string): Promise<{\r\n    count: number\r\n    errors: string[]\r\n  }> {\r\n    const errors: string[] = []\r\n    let count = 0\r\n\r\n    try {\r\n      const credentialsObfuscated = localStorage.getItem('social_media_credentials')\r\n      if (!credentialsObfuscated) return { count: 0, errors: [] }\r\n\r\n      // Deobfuscate (reverse + base64 decode)\r\n      const reversed = credentialsObfuscated.split('').reverse().join('')\r\n      const credentialsJson = atob(reversed)\r\n      const credentials: PlatformCredentials = JSON.parse(credentialsJson)\r\n\r\n      for (const [platform, platformCredentials] of Object.entries(credentials)) {\r\n        try {\r\n          if (!platformCredentials) continue\r\n\r\n          // Check if credentials already exist\r\n          const status = await CredentialService.getConnectionStatus(workspaceId)\r\n          if ((status as any)[platform]?.isConnected) {\r\n            console.log(`Credentials for ${platform} already exist, skipping`)\r\n            continue\r\n          }\r\n\r\n          await CredentialService.savePlatformCredentials(\r\n            platform as any,\r\n            platformCredentials as any,\r\n            userId,\r\n            workspaceId\r\n          )\r\n          count++\r\n        } catch (error) {\r\n          console.error(`Error migrating credentials for ${platform}:`, error)\r\n          errors.push(`Failed to migrate ${platform} credentials: ${(error as Error).message}`)\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error parsing credentials from localStorage:', error)\r\n      errors.push('Failed to parse credentials from localStorage')\r\n    }\r\n\r\n    return { count, errors }\r\n  }\r\n\r\n  /**\r\n   * Clear localStorage data after successful migration\r\n   */\r\n  static clearLocalStorageData(): void {\r\n    try {\r\n      localStorage.removeItem('socialMediaPosts')\r\n      localStorage.removeItem('campaigns')\r\n      localStorage.removeItem('social_media_credentials')\r\n      console.log('LocalStorage data cleared after migration')\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset migration status (for testing)\r\n   */\r\n  static resetMigrationStatus(): void {\r\n    localStorage.removeItem('migration_completed')\r\n  }\r\n}\r\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK","vendored","ReactServerDOMTurbopackServer"],"mappings":"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","ignoreList":[0,1,2]}