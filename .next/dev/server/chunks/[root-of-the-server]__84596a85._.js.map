{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/lib/supabase/server.ts"],"sourcesContent":["/**\r\n * Supabase Server Client\r\n * Use this client in server components, API routes, and server actions\r\n */\r\n\r\nimport { createServerClient, type CookieOptions } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\nimport type { Database } from './types'\r\n\r\nexport async function createClient() {\n  const cookieStore = await cookies()\n\r\n  return createServerClient<Database>(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        get(name: string) {\r\n          return cookieStore.get(name)?.value\r\n        },\r\n        set(name: string, value: string, options: CookieOptions) {\r\n          try {\r\n            cookieStore.set({ name, value, ...options })\r\n          } catch (error) {\r\n            // Handle cookie errors (happens in Server Components)\r\n          }\r\n        },\r\n        remove(name: string, options: CookieOptions) {\r\n          try {\r\n            cookieStore.set({ name, value: '', ...options })\r\n          } catch (error) {\r\n            // Handle cookie errors\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\n}\n\n// Alias to match existing imports in API routes\nexport { createClient as createServerClient }\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;AAAA;AACA;;;AAGO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,OAAO,IAAA,iMAAkB,sUAGvB;QACE,SAAS;YACP,KAAI,IAAY;gBACd,OAAO,YAAY,GAAG,CAAC,OAAO;YAChC;YACA,KAAI,IAAY,EAAE,KAAa,EAAE,OAAsB;gBACrD,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM;wBAAO,GAAG,OAAO;oBAAC;gBAC5C,EAAE,OAAO,OAAO;gBACd,sDAAsD;gBACxD;YACF;YACA,QAAO,IAAY,EAAE,OAAsB;gBACzC,IAAI;oBACF,YAAY,GAAG,CAAC;wBAAE;wBAAM,OAAO;wBAAI,GAAG,OAAO;oBAAC;gBAChD,EAAE,OAAO,OAAO;gBACd,uBAAuB;gBACzB;YACF;QACF;IACF;AAEJ","debugId":null}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/lib/supabase/index.ts/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const createBrowserClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call createBrowserClient() from the server but createBrowserClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts <module evaluation>\",\n    \"createBrowserClient\",\n);\nexport const supabase = registerClientReference(\n    function() { throw new Error(\"Attempted to call supabase() from the server but supabase is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts <module evaluation>\",\n    \"supabase\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;;;AACvE;;AACO,MAAM,sBAAsB,IAAA,0QAAuB,EACtD;IAAa,MAAM,IAAI,MAAM;AAAsP,GACnR,2DACA;AAEG,MAAM,WAAW,IAAA,0QAAuB,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAgO,GAC7P,2DACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/lib/supabase/index.ts/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const createBrowserClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call createBrowserClient() from the server but createBrowserClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts\",\n    \"createBrowserClient\",\n);\nexport const supabase = registerClientReference(\n    function() { throw new Error(\"Attempted to call supabase() from the server but supabase is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/lib/supabase/index.ts\",\n    \"supabase\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;;;AACvE;;AACO,MAAM,sBAAsB,IAAA,0QAAuB,EACtD;IAAa,MAAM,IAAI,MAAM;AAAsP,GACnR,uCACA;AAEG,MAAM,WAAW,IAAA,0QAAuB,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAgO,GAC7P,uCACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/services/database/auditLogService.ts"],"sourcesContent":["/**\r\n * Audit Log Service\r\n * Logs all credential-related events for compliance and debugging\r\n */\r\n\r\nimport { supabase } from '@/lib/supabase'\r\nimport type { Platform } from '@/types'\r\n\r\nexport interface AuditEventParams {\r\n  workspaceId: string\r\n  userId: string\r\n  platform: Platform\r\n  action: string\r\n  status: 'success' | 'failed' | 'partial'\r\n  errorMessage?: string\r\n  errorCode?: string\r\n  ipAddress?: string\r\n  userAgent?: string\r\n  requestPath?: string\r\n  metadata?: any\r\n}\r\n\r\n/**\r\n * Log an audit event\r\n */\r\nexport async function logAuditEvent({\r\n  workspaceId,\r\n  userId,\r\n  platform,\r\n  action,\r\n  status,\r\n  errorMessage,\r\n  errorCode,\r\n  ipAddress,\r\n  userAgent,\r\n  requestPath,\r\n  metadata,\r\n}: AuditEventParams): Promise<void> {\r\n  try {\r\n    const { error } = await supabase.from('credential_audit_log').insert({\r\n      workspace_id: workspaceId,\r\n      user_id: userId,\r\n      platform,\r\n      action,\r\n      status,\r\n      error_message: errorMessage || null,\r\n      error_code: errorCode || null,\r\n      ip_address: ipAddress || null,\r\n      user_agent: userAgent || null,\r\n      request_path: requestPath || null,\r\n      metadata: metadata || null,\r\n    } as any)\r\n\r\n    if (error) {\r\n      console.error('Failed to insert audit log:', error)\r\n    }\r\n  } catch (error) {\r\n    console.error('Audit logging error:', error)\r\n    // Don't throw - logging failures shouldn't break the app\r\n  }\r\n}\r\n\r\n/**\r\n * Get audit logs for a workspace\r\n */\r\nexport async function getAuditLogs(\r\n  workspaceId: string,\r\n  filters?: {\r\n    platform?: Platform\r\n    action?: string\r\n    status?: string\r\n    limit?: number\r\n    offset?: number\r\n    startDate?: Date\r\n    endDate?: Date\r\n  }\r\n): Promise<any[]> {\r\n  try {\r\n    let query = supabase\r\n      .from('credential_audit_log')\r\n      .select('*')\r\n      .eq('workspace_id', workspaceId)\r\n      .order('created_at', { ascending: false })\r\n\r\n    if (filters?.platform) {\r\n      query = query.eq('platform', filters.platform)\r\n    }\r\n\r\n    if (filters?.action) {\r\n      query = query.eq('action', filters.action)\r\n    }\r\n\r\n    if (filters?.status) {\r\n      query = query.eq('status', filters.status)\r\n    }\r\n\r\n    if (filters?.startDate) {\r\n      query = query.gte('created_at', filters.startDate.toISOString())\r\n    }\r\n\r\n    if (filters?.endDate) {\r\n      query = query.lte('created_at', filters.endDate.toISOString())\r\n    }\r\n\r\n    const limit = Math.min(filters?.limit || 100, 1000) // Cap at 1000\r\n    const offset = filters?.offset || 0\r\n\r\n    query = query.range(offset, offset + limit - 1)\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) throw error\r\n    return data || []\r\n  } catch (error) {\r\n    console.error('Error fetching audit logs:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Get audit logs for a specific user\r\n */\r\nexport async function getUserAuditLogs(\r\n  workspaceId: string,\r\n  userId: string,\r\n  options?: {\r\n    limit?: number\r\n    offset?: number\r\n  }\r\n): Promise<any[]> {\r\n  try {\r\n    let query = supabase\r\n      .from('credential_audit_log')\r\n      .select('*')\r\n      .eq('workspace_id', workspaceId)\r\n      .eq('user_id', userId)\r\n      .order('created_at', { ascending: false })\r\n\r\n    const limit = Math.min(options?.limit || 50, 500)\r\n    const offset = options?.offset || 0\r\n\r\n    query = query.range(offset, offset + limit - 1)\r\n\r\n    const { data, error } = await query\r\n\r\n    if (error) throw error\r\n    return data || []\r\n  } catch (error) {\r\n    console.error('Error fetching user audit logs:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Get summary of credential activities\r\n */\r\nexport async function getAuditSummary(\r\n  workspaceId: string,\r\n  days: number = 7\r\n): Promise<{\r\n  totalConnections: number\r\n  totalDisconnections: number\r\n  totalRefreshes: number\r\n  totalFailures: number\r\n  platformStats: Record<string, any>\r\n  recentActivity: any[]\r\n}> {\r\n  try {\r\n    const startDate = new Date()\r\n    startDate.setDate(startDate.getDate() - days)\r\n\r\n    const logs = await getAuditLogs(workspaceId, {\r\n      startDate,\r\n      limit: 1000,\r\n    })\r\n\r\n    const summary = {\r\n      totalConnections: 0,\r\n      totalDisconnections: 0,\r\n      totalRefreshes: 0,\r\n      totalFailures: 0,\r\n      platformStats: {\r\n        twitter: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        linkedin: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        facebook: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        instagram: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n      },\r\n      recentActivity: logs.slice(0, 10),\r\n    }\r\n\r\n    for (const log of logs) {\r\n      if (log.status === 'failed') {\r\n        summary.totalFailures++\r\n        ;(summary.platformStats as any)[(log as any).platform].failures++\r\n      }\r\n\r\n      if (log.action === 'platform_connected') {\r\n        summary.totalConnections++\r\n        ;(summary.platformStats as any)[(log as any).platform].connections++\r\n      } else if (log.action === 'platform_disconnected') {\r\n        summary.totalDisconnections++\r\n        ;(summary.platformStats as any)[(log as any).platform].disconnections++\r\n      } else if (log.action === 'token_refreshed') {\r\n        summary.totalRefreshes++\r\n        ;(summary.platformStats as any)[(log as any).platform].refreshes++\r\n      }\r\n    }\r\n\r\n    return summary\r\n  } catch (error) {\r\n    console.error('Error getting audit summary:', error)\r\n    return {\r\n      totalConnections: 0,\r\n      totalDisconnections: 0,\r\n      totalRefreshes: 0,\r\n      totalFailures: 0,\r\n      platformStats: {\r\n        twitter: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        linkedin: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        facebook: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n        instagram: { connections: 0, disconnections: 0, refreshes: 0, failures: 0 },\r\n      },\r\n      recentActivity: [],\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up old audit logs (older than 90 days)\r\n */\r\nexport async function cleanupOldAuditLogs(): Promise<number> {\r\n  try {\r\n    const ninetyDaysAgo = new Date()\r\n    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90)\r\n\r\n    const { data, error } = await supabase\r\n      .from('credential_audit_log')\r\n      .delete()\r\n      .lt('created_at', ninetyDaysAgo.toISOString())\r\n      .select('id')\r\n\r\n    if (error) throw error\r\n\r\n    return data?.length || 0\r\n  } catch (error) {\r\n    console.error('Error cleaning up audit logs:', error)\r\n    return 0\r\n  }\r\n}\r\n\r\n// ============================================\r\n// WORKSPACE-SPECIFIC AUDIT LOGGING\r\n// ============================================\r\n\r\nexport type WorkspaceAuditAction =\r\n  | 'member_invited'        // When someone sends an invite\r\n  | 'member_joined'         // When someone accepts invite\r\n  | 'member_removed'        // When admin removes a member\r\n  | 'member_role_changed'   // When admin changes member's role\r\n  | 'workspace_updated'     // When workspace settings change\r\n  | 'invite_revoked'        // When admin cancels an invite\r\n\r\nexport interface WorkspaceAuditLogParams {\r\n  workspaceId: string\r\n  userId: string\r\n  action: WorkspaceAuditAction\r\n  entityType: string\r\n  entityId: string\r\n  details: Record<string, any>\r\n}\r\n\r\n/**\r\n * Log workspace-related actions for audit trail\r\n * Used for: member invitations, role changes, removals, etc.\r\n *\r\n * @param params - Audit log parameters\r\n * @throws Errors are logged but not thrown to prevent breaking operations\r\n */\r\nexport async function logWorkspaceAction({\r\n  workspaceId,\r\n  userId,\r\n  action,\r\n  entityType,\r\n  entityId,\r\n  details,\r\n}: WorkspaceAuditLogParams): Promise<void> {\r\n  try {\r\n    const { error } = await (supabase.from('audit_logs') as any).insert({\r\n      workspace_id: workspaceId,\r\n      user_id: userId,\r\n      action,\r\n      entity_type: entityType,\r\n      entity_id: entityId,\r\n      details,\r\n      created_at: new Date().toISOString(),\r\n    })\r\n\r\n    if (error) {\r\n      console.error(`Failed to log workspace action \"${action}\":`, error)\r\n    }\r\n  } catch (error) {\r\n    console.error('Workspace audit logging error:', error)\r\n    // Don't throw - logging failures shouldn't break the app\r\n  }\r\n}\r\n\r\n/**\r\n * Get workspace activity log with filters\r\n *\r\n * @param workspaceId - Workspace to get activity for\r\n * @param filters - Optional filters for activity type, user, date range\r\n * @returns Paginated activity logs with total count\r\n */\r\nexport async function getWorkspaceActivityLog(\r\n  workspaceId: string,\r\n  filters?: {\r\n    userId?: string\r\n    action?: WorkspaceAuditAction\r\n    startDate?: Date\r\n    endDate?: Date\r\n    limit?: number\r\n    offset?: number\r\n  }\r\n): Promise<{\r\n  data: any[]\r\n  total: number\r\n  limit: number\r\n  offset: number\r\n  hasMore: boolean\r\n}> {\r\n  try {\r\n    // Build the query\r\n    let query = supabase\r\n      .from('audit_logs')\r\n      .select(\r\n        `\r\n        id,\r\n        workspace_id,\r\n        user_id,\r\n        action,\r\n        entity_type,\r\n        entity_id,\r\n        details,\r\n        created_at,\r\n        users:user_id (\r\n          email,\r\n          full_name\r\n        )\r\n      `,\r\n        { count: 'exact' }\r\n      )\r\n      .eq('workspace_id', workspaceId)\r\n      .order('created_at', { ascending: false })\r\n\r\n    // Apply filters\r\n    if (filters?.userId) {\r\n      query = query.eq('user_id', filters.userId)\r\n    }\r\n\r\n    if (filters?.action) {\r\n      query = query.eq('action', filters.action)\r\n    }\r\n\r\n    if (filters?.startDate) {\r\n      query = query.gte('created_at', filters.startDate.toISOString())\r\n    }\r\n\r\n    if (filters?.endDate) {\r\n      query = query.lte('created_at', filters.endDate.toISOString())\r\n    }\r\n\r\n    // Pagination\r\n    const limit = Math.min(filters?.limit || 50, 500) // Cap at 500\r\n    const offset = filters?.offset || 0\r\n    query = query.range(offset, offset + limit - 1)\r\n\r\n    const { data, error, count } = await query\r\n\r\n    if (error) {\r\n      console.error('Error fetching workspace activity log:', error)\r\n      throw error\r\n    }\r\n\r\n    return {\r\n      data: data || [],\r\n      total: count || 0,\r\n      limit,\r\n      offset,\r\n      hasMore: (count || 0) > offset + limit,\r\n    }\r\n  } catch (error) {\r\n    console.error('Error getting workspace activity log:', error)\r\n    return {\r\n      data: [],\r\n      total: 0,\r\n      limit: filters?.limit || 50,\r\n      offset: filters?.offset || 0,\r\n      hasMore: false,\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/services/database/inviteService.ts"],"sourcesContent":["/**\r\n * Invite Service\r\n * Manages workspace invitations with security features\r\n * Includes: token generation, validation, expiry checking, email verification\r\n */\r\n\r\nimport { createServerClient } from '@/lib/supabase/server'\r\nimport type { WorkspaceInvite, CreateInviteInput } from '@/types/workspace'\r\nimport { logWorkspaceAction } from './auditLogService'\r\nimport crypto from 'crypto'\r\n\r\n/**\r\n * Invite Service - Static methods for invitation management\r\n * Handles creation, validation, acceptance, and revocation of invitations\r\n */\r\nexport class InviteService {\r\n  /**\r\n   * Generate a cryptographically secure random token\r\n   * Used for both shareable links and email invitations\r\n   *\r\n   * @returns URL-safe base64 encoded 32-byte random token\r\n   * @throws Never throws - always generates valid token\r\n   */\r\n  private static generateToken(): string {\r\n    // Generate 32 random bytes (256 bits of entropy)\r\n    // base64url encoding is safe for URLs (no +, /, = characters)\r\n    return crypto.randomBytes(32).toString('base64url')\r\n  }\r\n\r\n  /**\r\n   * Calculate expiration date based on days\r\n   * Returns ISO timestamp or null for never-expiring invites\r\n   *\r\n   * @param days - Number of days until expiration (null = never expires)\r\n   * @returns ISO timestamp string or null\r\n   */\r\n  private static calculateExpiration(days?: number | null): string | null {\r\n    if (!days || days <= 0) return null\r\n\r\n    const expiryDate = new Date()\r\n    expiryDate.setDate(expiryDate.getDate() + days)\r\n    return expiryDate.toISOString()\r\n  }\r\n\r\n  /**\r\n   * Create a new invitation\r\n   * Generates a secure token and stores invitation record\r\n   * Supports both email-specific and shareable link invitations\r\n   *\r\n   * @param workspaceId - Workspace to invite to\r\n   * @param input - Invitation details (email optional, role required, expiry optional)\r\n   * @param invitedBy - User ID creating the invite\r\n   * @returns Created invite object or null if failed\r\n   */\r\n  static async createInvite(\r\n    workspaceId: string,\r\n    input: CreateInviteInput,\r\n    invitedBy: string\r\n  ): Promise<WorkspaceInvite | null> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Validate input\r\n      const validRoles = ['admin', 'editor', 'viewer']\r\n      if (!validRoles.includes(input.role)) {\r\n        console.warn('Invalid role in createInvite:', input.role)\r\n        return null\r\n      }\r\n\r\n      // Validate email if provided\r\n      if (input.email && !input.email.includes('@')) {\r\n        console.warn('Invalid email format:', input.email)\r\n        return null\r\n      }\r\n\r\n      // Generate unique secure token\r\n      const token = this.generateToken()\r\n\r\n      // Calculate expiration time\r\n      const expiresAt = this.calculateExpiration(input.expiresInDays)\r\n\r\n      // Create the invitation in database\r\n      const { data, error } = await (supabase\r\n        .from('workspace_invites') as any)\r\n        .insert({\r\n          workspace_id: workspaceId,\r\n          email: input.email || null, // NULL for shareable links\r\n          role: input.role,\r\n          token,\r\n          expires_at: expiresAt,\r\n          invited_by: invitedBy,\r\n        })\r\n        .select()\r\n        .single()\r\n\r\n      if (error) {\r\n        console.error('Error creating invite:', error)\r\n        return null\r\n      }\r\n\r\n      // Log the action\r\n      await logWorkspaceAction({\r\n        workspaceId,\r\n        userId: invitedBy,\r\n        action: 'member_invited',\r\n        entityType: 'workspace_invite',\r\n        entityId: data.id,\r\n        details: {\r\n          invite_email: input.email || 'shareable_link',\r\n          invite_role: input.role,\r\n          expires_at: expiresAt,\r\n        },\r\n      })\r\n\r\n      return data as WorkspaceInvite\r\n    } catch (error) {\r\n      console.error('Unexpected error in createInvite:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all pending invitations for a workspace\r\n   * Used by admins to view and manage active invites\r\n   *\r\n   * @param workspaceId - Workspace to get invites for\r\n   * @returns Array of pending invites, empty array if none or error\r\n   */\r\n  static async getWorkspaceInvites(workspaceId: string): Promise<WorkspaceInvite[]> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      const { data, error } = await supabase\r\n        .from('workspace_invites')\r\n        .select('*')\r\n        .eq('workspace_id', workspaceId)\r\n        .is('used_at', null) // Only pending (unused) invites\r\n        .order('created_at', { ascending: false })\r\n\r\n      if (error) {\r\n        console.error('Error fetching workspace invites:', error)\r\n        return []\r\n      }\r\n\r\n      return data as WorkspaceInvite[]\r\n    } catch (error) {\r\n      console.error('Unexpected error in getWorkspaceInvites:', error)\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate an invitation token\r\n   * Checks: token exists, not already used, not expired\r\n   * Safe to call from public endpoints\r\n   *\r\n   * @param token - Invitation token to validate\r\n   * @returns Valid invite object or null if invalid/expired/used\r\n   */\r\n  static async validateInvite(token: string): Promise<WorkspaceInvite | null> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Find the invite by token\r\n      const { data, error } = await supabase\r\n        .from('workspace_invites')\r\n        .select('*')\r\n        .eq('token', token)\r\n        .is('used_at', null) // Must not be already used\r\n        .single()\r\n\r\n      if (error || !data) {\r\n        // Token not found or already used\r\n        return null\r\n      }\r\n\r\n      const invite = data as WorkspaceInvite\r\n\r\n      // Check if invite has expired\r\n      if (invite.expires_at) {\r\n        const expiryDate = new Date(invite.expires_at)\r\n        const now = new Date()\r\n\r\n        if (now > expiryDate) {\r\n          // Invite has expired\r\n          return null\r\n        }\r\n      }\r\n\r\n      // Token is valid\r\n      return invite\r\n    } catch (error) {\r\n      console.error('Unexpected error in validateInvite:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Accept an invitation and add user to workspace\r\n   * Updates user's workspace and role, marks invite as used\r\n   * Called when user clicks invite link and is logged in\r\n   *\r\n   * @param token - Invitation token to accept\r\n   * @param userId - User ID accepting the invite\r\n   * @returns Success boolean\r\n   */\r\n  static async acceptInvite(token: string, userId: string): Promise<boolean> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Step 1: Validate the invite (must be valid and not expired)\r\n      const invite = await this.validateInvite(token)\r\n      if (!invite) {\r\n        console.warn('Invalid or expired invitation token')\r\n        return false\r\n      }\r\n\r\n      // Step 2: Get user's current information\r\n      const { data: userData } = await supabase\r\n        .from('users')\r\n        .select('email, workspace_id')\r\n        .eq('id', userId)\r\n        .single()\r\n\r\n      if (!userData) {\r\n        console.warn('User not found:', userId)\r\n        return false\r\n      }\r\n\r\n      // Step 3: For email invites, verify email matches\r\n      if (invite.email && invite.email !== (userData as any).email) {\r\n        console.warn('Email mismatch for email-specific invite')\r\n        return false // Email doesn't match the invite recipient\r\n      }\r\n\r\n      // Step 4: Update user's workspace assignment and role\r\n      const { error: updateError } = await (supabase\r\n        .from('users') as any)\r\n        .update({\r\n          workspace_id: invite.workspace_id,\r\n          role: invite.role,\r\n        })\r\n        .eq('id', userId)\r\n\r\n      if (updateError) {\r\n        console.error('Error updating user workspace:', updateError)\r\n        return false\r\n      }\r\n\r\n      // Step 5: Mark invite as used\r\n      const { error: inviteError } = await (supabase\r\n        .from('workspace_invites') as any)\r\n        .update({\r\n          used_at: new Date().toISOString(),\r\n          used_by: userId,\r\n        })\r\n        .eq('id', invite.id)\r\n\r\n      if (inviteError) {\r\n        console.error('Error marking invite as used:', inviteError)\r\n        // This is not fatal - user is already in workspace\r\n        // But we should log it\r\n      }\r\n\r\n      // Step 6: Log the action\r\n      await logWorkspaceAction({\r\n        workspaceId: invite.workspace_id,\r\n        userId,\r\n        action: 'member_joined',\r\n        entityType: 'workspace_invite',\r\n        entityId: invite.id,\r\n        details: {\r\n          invite_id: invite.id,\r\n          role: invite.role,\r\n          invited_by: invite.invited_by,\r\n          previous_workspace_id: (userData as any).workspace_id,\r\n        },\r\n      })\r\n\r\n      return true\r\n    } catch (error) {\r\n      console.error('Unexpected error in acceptInvite:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke (cancel) an invitation\r\n   * Deletes the invite so it cannot be used\r\n   * Only admins can do this\r\n   *\r\n   * @param inviteId - Invite ID to revoke\r\n   * @param workspaceId - Workspace (for verification)\r\n   * @param revokedBy - Admin performing the action\r\n   * @returns Success boolean\r\n   */\r\n  static async revokeInvite(\r\n    inviteId: string,\r\n    workspaceId: string,\r\n    revokedBy: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Get invite details before deleting (for audit log)\r\n      const { data: invite } = await supabase\r\n        .from('workspace_invites')\r\n        .select('*')\r\n        .eq('id', inviteId)\r\n        .eq('workspace_id', workspaceId) // Verify workspace match\r\n        .single()\r\n\r\n      if (!invite) {\r\n        console.warn('Invite not found for revocation:', inviteId)\r\n        return false\r\n      }\r\n\r\n      // Delete the invite\r\n      const { error } = await supabase\r\n        .from('workspace_invites')\r\n        .delete()\r\n        .eq('id', inviteId)\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) {\r\n        console.error('Error revoking invite:', error)\r\n        return false\r\n      }\r\n\r\n      // Log the action\r\n      await logWorkspaceAction({\r\n        workspaceId,\r\n        userId: revokedBy,\r\n        action: 'invite_revoked',\r\n        entityType: 'workspace_invite',\r\n        entityId: inviteId,\r\n        details: {\r\n          invite_email: (invite as any).email || 'shareable_link',\r\n          invite_role: (invite as any).role,\r\n          expires_at: (invite as any).expires_at,\r\n        },\r\n      })\r\n\r\n      return true\r\n    } catch (error) {\r\n      console.error('Unexpected error in revokeInvite:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resend an invitation email\r\n   * Creates a new invite with same role and workspace\r\n   * Used when user wants to send invite to same email again\r\n   *\r\n   * @param inviteId - Original invite ID to reference\r\n   * @param workspaceId - Workspace\r\n   * @param resendBy - Admin performing the resend\r\n   * @returns New invite object or null if failed\r\n   */\r\n  static async resendInvite(\r\n    inviteId: string,\r\n    workspaceId: string,\r\n    resendBy: string\r\n  ): Promise<WorkspaceInvite | null> {\r\n    try {\r\n      // Get original invite details\r\n      const supabase = await createServerClient()\r\n\r\n      const { data: originalInvite } = await supabase\r\n        .from('workspace_invites')\r\n        .select('*')\r\n        .eq('id', inviteId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (!originalInvite || !(originalInvite as any).email) {\r\n        console.warn('Original invite not found or is not email-based:', inviteId)\r\n        return null\r\n      }\r\n\r\n      // Create new invite with same details\r\n      return await this.createInvite(\r\n        workspaceId,\r\n        {\r\n          email: (originalInvite as any).email,\r\n          role: (originalInvite as any).role,\r\n        },\r\n        resendBy\r\n      )\r\n    } catch (error) {\r\n      console.error('Unexpected error in resendInvite:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if invite is expired\r\n   * Utility method to check expiration status\r\n   *\r\n   * @param expiresAt - Expiration date ISO string or null\r\n   * @returns True if expired, false if valid or never expires\r\n   */\r\n  static isInviteExpired(expiresAt: string | null): boolean {\r\n    if (!expiresAt) return false // Never expires\r\n    return new Date() > new Date(expiresAt)\r\n  }\r\n\r\n  /**\r\n   * Get time remaining for invite\r\n   * Utility method to display countdown\r\n   *\r\n   * @param expiresAt - Expiration date ISO string or null\r\n   * @returns Time remaining in milliseconds, 0 if expired, Infinity if never expires\r\n   */\r\n  static getTimeRemaining(expiresAt: string | null): number {\r\n    if (!expiresAt) return Infinity // Never expires\r\n    const remaining = new Date(expiresAt).getTime() - Date.now()\r\n    return Math.max(remaining, 0)\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 795, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/services/database/workspaceService.ts"],"sourcesContent":["/**\r\n * Workspace Service\r\n * Handles all database operations related to workspace management\r\n * Includes: workspace CRUD, member management, capacity checks\r\n */\r\n\r\nimport { createServerClient } from '@/lib/supabase/server'\r\nimport type { Workspace, UpdateWorkspaceInput, WorkspaceMember } from '@/types/workspace'\r\nimport { logWorkspaceAction } from './auditLogService'\r\n\r\n/**\r\n * Workspace Service - Static methods for workspace operations\r\n * All methods use server-side Supabase client for security\r\n */\r\nexport class WorkspaceService {\r\n  /**\r\n   * Get workspace by ID\r\n   * Retrieves complete workspace information\r\n   *\r\n   * @param workspaceId - The workspace ID to fetch\r\n   * @returns Workspace object or null if not found\r\n   * @throws Logs error but doesn't throw\r\n   */\r\n  static async getWorkspace(workspaceId: string): Promise<Workspace | null> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      const { data, error } = await supabase\r\n        .from('workspaces')\r\n        .select('*')\r\n        .eq('id', workspaceId)\r\n        .single()\r\n\r\n      if (error) {\r\n        if (error.code !== 'PGRST116') {\r\n          // PGRST116 is \"no rows returned\" - expected for not found\r\n          console.error('Error fetching workspace:', error)\r\n        }\r\n        return null\r\n      }\r\n\r\n      return data as Workspace\r\n    } catch (error) {\r\n      console.error('Unexpected error in getWorkspace:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update workspace settings\r\n   * Only admins can do this (enforced by RLS policy)\r\n   *\r\n   * @param workspaceId - Workspace to update\r\n   * @param updates - Fields to update (name, max_users, settings)\r\n   * @param userId - User making the change (for audit log)\r\n   * @returns Updated workspace or null if failed\r\n   * @throws Errors are caught and logged\r\n   */\r\n  static async updateWorkspace(\r\n    workspaceId: string,\r\n    updates: UpdateWorkspaceInput,\r\n    userId: string\r\n  ): Promise<Workspace | null> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Build update object with timestamp\r\n      const updateData: any = {\r\n        ...updates,\r\n        updated_at: new Date().toISOString(),\r\n      }\r\n\r\n      // Validate max_users if provided\r\n      if (updateData.max_users && updateData.max_users < 1) {\r\n        console.warn('Invalid max_users value:', updateData.max_users)\r\n        delete updateData.max_users // Don't update invalid value\r\n      }\r\n\r\n      // Validate name if provided\r\n      if (updateData.name && updateData.name.trim().length === 0) {\r\n        console.warn('Invalid workspace name (empty string)')\r\n        delete updateData.name\r\n      }\r\n\r\n      if (Object.keys(updateData).length === 1) {\r\n        // Only updated_at, nothing to actually update\r\n        return await this.getWorkspace(workspaceId)\r\n      }\r\n\r\n      // Update the workspace\r\n      const { data, error } = await (supabase\r\n        .from('workspaces') as any)\r\n        .update(updateData)\r\n        .eq('id', workspaceId)\r\n        .select()\r\n        .single()\r\n\r\n      if (error) {\r\n        console.error('Error updating workspace:', error)\r\n        return null\r\n      }\r\n\r\n      // Log the action\r\n      await logWorkspaceAction({\r\n        workspaceId,\r\n        userId,\r\n        action: 'workspace_updated',\r\n        entityType: 'workspace',\r\n        entityId: workspaceId,\r\n        details: updates,\r\n      })\r\n\r\n      return data as Workspace\r\n    } catch (error) {\r\n      console.error('Unexpected error in updateWorkspace:', error)\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all members in a workspace\r\n   * Includes: id, email, name, avatar, role, and join date\r\n   *\r\n   * @param workspaceId - Workspace to get members for\r\n   * @returns Array of workspace members, empty array if none or error\r\n   */\r\n  static async getWorkspaceMembers(workspaceId: string): Promise<WorkspaceMember[]> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      const { data, error } = await supabase\r\n        .from('users')\r\n        .select('id, email, full_name, avatar_url, role, created_at, workspace_id')\r\n        .eq('workspace_id', workspaceId)\r\n        .order('created_at', { ascending: true }) // Oldest members first\r\n\r\n      if (error) {\r\n        console.error('Error fetching workspace members:', error)\r\n        return []\r\n      }\r\n\r\n      return data as WorkspaceMember[]\r\n    } catch (error) {\r\n      console.error('Unexpected error in getWorkspaceMembers:', error)\r\n      return []\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a member from workspace\r\n   * This permanently deletes the user account in that workspace\r\n   * Note: Cascading deletes will remove their posts, credentials, etc.\r\n   * Only admins can do this (permission checked in API route)\r\n   *\r\n   * @param workspaceId - Current workspace\r\n   * @param userId - User to remove\r\n   * @param removedBy - Admin performing the action (for audit log)\r\n   * @returns Success boolean\r\n   */\r\n  static async removeMember(\r\n    workspaceId: string,\r\n    userId: string,\r\n    removedBy: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Get member info before deleting (for audit log)\r\n      const { data: member } = await supabase\r\n        .from('users')\r\n        .select('email, full_name, role')\r\n        .eq('id', userId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (!member) {\r\n        console.warn('Member not found for removal:', userId)\r\n        return false\r\n      }\r\n\r\n      // Delete the user from this workspace\r\n      // Note: This cascades to delete their posts, credentials, campaigns, etc.\r\n      const { error } = await supabase\r\n        .from('users')\r\n        .delete()\r\n        .eq('id', userId)\r\n        .eq('workspace_id', workspaceId) // Extra safety check\r\n\r\n      if (error) {\r\n        console.error('Error removing member:', error)\r\n        return false\r\n      }\r\n\r\n      // Log the action\r\n      await logWorkspaceAction({\r\n        workspaceId,\r\n        userId: removedBy,\r\n        action: 'member_removed',\r\n        entityType: 'workspace_member',\r\n        entityId: userId,\r\n        details: {\r\n          removed_user_id: userId,\r\n          removed_user_email: (member as any).email,\r\n          removed_user_role: (member as any).role,\r\n        },\r\n      })\r\n\r\n      return true\r\n    } catch (error) {\r\n      console.error('Unexpected error in removeMember:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change a member's role\r\n   * Allows admins to promote/demote members between admin, editor, and viewer roles\r\n   * Only admins can do this (permission checked in API route)\r\n   *\r\n   * @param workspaceId - Current workspace\r\n   * @param userId - User whose role to change\r\n   * @param newRole - New role to assign (admin, editor, viewer)\r\n   * @param changedBy - Admin performing the action (for audit log)\r\n   * @returns Success boolean\r\n   */\r\n  static async changeMemberRole(\r\n    workspaceId: string,\r\n    userId: string,\r\n    newRole: 'admin' | 'editor' | 'viewer',\r\n    changedBy: string\r\n  ): Promise<boolean> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Validate role\r\n      const validRoles = ['admin', 'editor', 'viewer']\r\n      if (!validRoles.includes(newRole)) {\r\n        console.warn('Invalid role provided:', newRole)\r\n        return false\r\n      }\r\n\r\n      // Get old role (for audit log)\r\n      const { data: member } = await supabase\r\n        .from('users')\r\n        .select('role, email')\r\n        .eq('id', userId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (!member) {\r\n        console.warn('Member not found for role change:', userId)\r\n        return false\r\n      }\r\n\r\n      // Don't update if role is already the same\r\n      if ((member as any).role === newRole) {\r\n        console.info('Role already set to:', newRole)\r\n        return true // Not an error, just no-op\r\n      }\r\n\r\n      // Update the role\r\n      const { error } = await (supabase\r\n        .from('users') as any)\r\n        .update({ role: newRole })\r\n        .eq('id', userId)\r\n        .eq('workspace_id', workspaceId) // Extra safety check\r\n\r\n      if (error) {\r\n        console.error('Error changing role:', error)\r\n        return false\r\n      }\r\n\r\n      // Log the action\r\n      await logWorkspaceAction({\r\n        workspaceId,\r\n        userId: changedBy,\r\n        action: 'member_role_changed',\r\n        entityType: 'workspace_member',\r\n        entityId: userId,\r\n        details: {\r\n          target_user_id: userId,\r\n          target_user_email: (member as any).email,\r\n          old_role: (member as any).role,\r\n          new_role: newRole,\r\n        },\r\n      })\r\n\r\n      return true\r\n    } catch (error) {\r\n      console.error('Unexpected error in changeMemberRole:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if workspace is at capacity\r\n   * Compares current member count to max_users setting\r\n   *\r\n   * @param workspaceId - Workspace to check\r\n   * @returns True if workspace is at or over max capacity\r\n   */\r\n  static async isWorkspaceFull(workspaceId: string): Promise<boolean> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      // Get workspace max_users setting\r\n      const { data: workspace } = await supabase\r\n        .from('workspaces')\r\n        .select('max_users')\r\n        .eq('id', workspaceId)\r\n        .single()\r\n\r\n      if (!workspace) {\r\n        console.warn('Workspace not found for capacity check:', workspaceId)\r\n        return true // Err on side of caution - don't allow join if workspace unknown\r\n      }\r\n\r\n      // Count current members\r\n      const { count, error } = await supabase\r\n        .from('users')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) {\r\n        console.error('Error counting workspace members:', error)\r\n        return true // Err on side of caution\r\n      }\r\n\r\n      const memberCount = count ?? 0\r\n      return memberCount >= (workspace as any).max_users\r\n    } catch (error) {\r\n      console.error('Unexpected error in isWorkspaceFull:', error)\r\n      return true // Err on side of caution\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace member count\r\n   * Returns the current number of members in the workspace\r\n   *\r\n   * @param workspaceId - Workspace to count members for\r\n   * @returns Number of members, 0 if error or workspace not found\r\n   */\r\n  static async getWorkspaceMemberCount(workspaceId: string): Promise<number> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      const { count, error } = await supabase\r\n        .from('users')\r\n        .select('*', { count: 'exact', head: true })\r\n        .eq('workspace_id', workspaceId)\r\n\r\n      if (error) {\r\n        console.error('Error counting members:', error)\r\n        return 0\r\n      }\r\n\r\n      return count ?? 0\r\n    } catch (error) {\r\n      console.error('Unexpected error in getWorkspaceMemberCount:', error)\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get workspace member by ID\r\n   * Retrieves a single member's information\r\n   *\r\n   * @param workspaceId - Workspace to search in\r\n   * @param userId - User to find\r\n   * @returns Member object or null if not found\r\n   */\r\n  static async getWorkspaceMember(\r\n    workspaceId: string,\r\n    userId: string\r\n  ): Promise<WorkspaceMember | null> {\r\n    try {\r\n      const supabase = await createServerClient()\r\n\r\n      const { data, error } = await supabase\r\n        .from('users')\r\n        .select('id, email, full_name, avatar_url, role, created_at, workspace_id')\r\n        .eq('id', userId)\r\n        .eq('workspace_id', workspaceId)\r\n        .single()\r\n\r\n      if (error) {\r\n        if (error.code !== 'PGRST116') {\r\n          console.error('Error fetching member:', error)\r\n        }\r\n        return null\r\n      }\r\n\r\n      return data as WorkspaceMember\r\n    } catch (error) {\r\n      console.error('Unexpected error in getWorkspaceMember:', error)\r\n      return null\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1102, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aamir/social_media_os/src/app/api/workspace/invites/route.ts"],"sourcesContent":["/**\r\n * API Route: /api/workspace/invites\r\n * Methods: GET, POST, DELETE\r\n *\r\n * GET: List all pending invites for workspace (admin only)\r\n * POST: Create a new invitation (admin only)\r\n * DELETE: Revoke an invitation (admin only)\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server'\r\nimport { createServerClient } from '@/lib/supabase/server'\r\nimport { InviteService } from '@/services/database/inviteService'\r\nimport { WorkspaceService } from '@/services/database/workspaceService'\r\nimport type { CreateInviteInput } from '@/types/workspace'\r\n\r\n/**\r\n * GET /api/workspace/invites\r\n * Get all pending invitations for the workspace\r\n * Requires: Admin role\r\n *\r\n * Response: { data: WorkspaceInvite[] } or { error: string }\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const supabase = await createServerClient()\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser()\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    // Get user's workspace and role\r\n    const { data: userData, error: userError } = await supabase\r\n      .from('users')\r\n      .select('workspace_id, role')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (userError || !userData || !('workspace_id' in userData)) {\r\n      return NextResponse.json(\r\n        { error: 'User profile not found' },\r\n        { status: 404 }\r\n      )\r\n    }\r\n\r\n    // Only admins can view invites\r\n    if ((userData as any).role !== 'admin') {\r\n      return NextResponse.json(\r\n        { error: 'Only admins can view invitations' },\r\n        { status: 403 }\r\n      )\r\n    }\r\n\r\n    // Get all pending invites\r\n    const invites = await InviteService.getWorkspaceInvites((userData as any).workspace_id)\r\n\r\n    return NextResponse.json({ data: invites })\r\n  } catch (error) {\r\n    console.error('Error in GET /api/workspace/invites:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * POST /api/workspace/invites\r\n * Create a new invitation\r\n * Requires: Admin role\r\n *\r\n * Body: { email?: string, role: UserRole, expiresInDays?: number }\r\n * Response: { data: { invite: WorkspaceInvite, inviteUrl: string } } or { error: string }\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const supabase = await createServerClient()\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser()\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    // Get user's workspace and role\r\n    const { data: userData, error: userError } = await supabase\r\n      .from('users')\r\n      .select('workspace_id, role')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (userError || !userData || !('workspace_id' in userData)) {\r\n      return NextResponse.json(\r\n        { error: 'User profile not found' },\r\n        { status: 404 }\r\n      )\r\n    }\r\n\r\n    // Check if user is admin\r\n    if ((userData as any).role !== 'admin') {\r\n      return NextResponse.json(\r\n        { error: 'Only admins can create invitations' },\r\n        { status: 403 }\r\n      )\r\n    }\r\n\r\n    // Check if workspace is full\r\n    const isFull = await WorkspaceService.isWorkspaceFull((userData as any).workspace_id)\r\n    if (isFull) {\r\n      return NextResponse.json(\r\n        { error: 'Workspace is at maximum capacity' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Parse request body\r\n    let input: CreateInviteInput\r\n    try {\r\n      input = await request.json()\r\n    } catch (error) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid JSON in request body' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Validate input\r\n    const validRoles = ['admin', 'editor', 'viewer']\r\n    if (!validRoles.includes(input.role)) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid role' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    if (input.email && !input.email.includes('@')) {\r\n      return NextResponse.json(\r\n        { error: 'Invalid email address' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    if (input.expiresInDays !== undefined && input.expiresInDays !== null) {\r\n      if (input.expiresInDays < 1 || input.expiresInDays > 365) {\r\n        return NextResponse.json(\r\n          { error: 'Expiration must be between 1 and 365 days' },\r\n          { status: 400 }\r\n        )\r\n      }\r\n    }\r\n\r\n    // Create the invite\r\n    const invite = await InviteService.createInvite(\r\n      (userData as any).workspace_id,\r\n      input,\r\n      user.id\r\n    )\r\n\r\n    if (!invite) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to create invitation' },\r\n        { status: 500 }\r\n      )\r\n    }\r\n\r\n    // Build invite URL\r\n    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\r\n    const inviteUrl = `${baseUrl}/invite/${invite.token}`\r\n\r\n    return NextResponse.json({\r\n      data: {\r\n        invite,\r\n        inviteUrl,\r\n      },\r\n    })\r\n  } catch (error) {\r\n    console.error('Error in POST /api/workspace/invites:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * DELETE /api/workspace/invites\r\n * Revoke an invitation\r\n * Requires: Admin role\r\n *\r\n * Query params: inviteId - Invite ID to revoke\r\n * Response: { success: true } or { error: string }\r\n */\r\nexport async function DELETE(request: NextRequest) {\r\n  try {\r\n    const supabase = await createServerClient()\r\n    const { data: { user }, error: authError } = await supabase.auth.getUser()\r\n\r\n    if (authError || !user) {\r\n      return NextResponse.json(\r\n        { error: 'Unauthorized' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    // Get invite ID from query params\r\n    const { searchParams } = new URL(request.url)\r\n    const inviteId = searchParams.get('inviteId')\r\n\r\n    if (!inviteId) {\r\n      return NextResponse.json(\r\n        { error: 'Missing inviteId query parameter' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Get user's workspace and role\r\n    const { data: userData, error: userError } = await supabase\r\n      .from('users')\r\n      .select('workspace_id, role')\r\n      .eq('id', user.id)\r\n      .single()\r\n\r\n    if (userError || !userData || !('workspace_id' in userData)) {\r\n      return NextResponse.json(\r\n        { error: 'User profile not found' },\r\n        { status: 404 }\r\n      )\r\n    }\r\n\r\n    // Check if user is admin\r\n    if ((userData as any).role !== 'admin') {\r\n      return NextResponse.json(\r\n        { error: 'Only admins can revoke invitations' },\r\n        { status: 403 }\r\n      )\r\n    }\r\n\r\n    // Revoke the invite\r\n    const success = await InviteService.revokeInvite(\r\n      inviteId,\r\n      (userData as any).workspace_id,\r\n      user.id\r\n    )\r\n\r\n    if (!success) {\r\n      return NextResponse.json(\r\n        { error: 'Failed to revoke invitation' },\r\n        { status: 500 }\r\n      )\r\n    }\r\n\r\n    return NextResponse.json({ success: true })\r\n  } catch (error) {\r\n    console.error('Error in DELETE /api/workspace/invites:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}